<test-set covers="group-by" name="prod-GroupByClause" xmlns="http://www.w3.org/2010/09/qt-fots-catalog">
  <description>Tests for the GroupByClause production in XQuery 3.0</description>
  <link document="http://www.w3.org/TR/xquery-30/" idref="doc-xquery30-GroupByClause" type="spec"/>
  <link document="XQuery" idref="id-for-group-by" section-number="3.8.1" type="spec"/>
  <environment name="GroupByUseCases">
    <source file="GroupByClause/products.xml" role="$products-doc">
      <description>Taken from XQuery 3.0 Use Cases</description>
      <created by="Andrew Eisenberg" on="2012-03-14"/>
    </source>
    <source file="GroupByClause/sales-records.xml" role="$sales-records-doc">
      <description>Taken from XQuery 3.0 Use Cases</description>
      <created by="Andrew Eisenberg" on="2012-03-14"/>
    </source>
    <source file="GroupByClause/stores.xml" role="$stores-doc">
      <description>Taken from XQuery 3.0 Use Cases</description>
      <created by="Andrew Eisenberg" on="2012-03-14"/>
    </source>
    <source file="GroupByClause/books.xml" role="$books-doc">
      <description>Taken from XQuery 3.0 Use Cases</description>
      <created by="Andrew Eisenberg" on="2012-03-14"/>
    </source>
  </environment>
  <dependency type="spec" value="XQ30+"/>
  <test-case name="group-001"><response-string xmlns:qt="http://www.w3.org/2010/09/qt-fots-catalog">(xs:string("1 11 21 31 41 51 61 71 81 91"),xs:string("2 12 22 32 42 52 62 72 82 92"),xs:string("3 13 23 33 43 53 63 73 83 93"),xs:string("4 14 24 34 44 54 64 74 84 94"),xs:string("5 15 25 35 45 55 65 75 85 95"),xs:string("6 16 26 36 46 56 66 76 86 96"),xs:string("7 17 27 37 47 57 67 77 87 97"),xs:string("8 18 28 38 48 58 68 78 88 98"),xs:string("9 19 29 39 49 59 69 79 89 99"),xs:string("10 20 30 40 50 60 70 80 90 100"))</response-string>
    <description>Group atomic values</description>
    <created by="Michael Kay" on="2008-11-26"/>
    <modified by="Michael Kay" change="order of groups is undefined" on="2011-08-01"/>
    <test> 
            for $x in 1 to 100 
            let $key := $x mod 10 
            group by $key 
            return string(text{$x})
      </test>
    <result-string>(xs:string("1 11 21 31 41 51 61 71 81 91"),xs:string("2 12 22 32 42 52 62 72 82 92"),xs:string("3 13 23 33 43 53 63 73 83 93"),xs:string("4 14 24 34 44 54 64 74 84 94"),xs:string("5 15 25 35 45 55 65 75 85 95"),xs:string("6 16 26 36 46 56 66 76 86 96"),xs:string("7 17 27 37 47 57 67 77 87 97"),xs:string("8 18 28 38 48 58 68 78 88 98"),xs:string("9 19 29 39 49 59 69 79 89 99"),xs:string("10 20 30 40 50 60 70 80 90 100"))</result-string>
    <result>
      <assert-permutation>"1 11 21 31 41 51 61 71 81 91", "2 12 22 32 42 52 62 72 82 92", "3 13 23 33 43 53 63 73 83 93", 
            "4 14 24 34 44 54 64 74 84 94", "5 15 25 35 45 55 65 75 85 95", "6 16 26 36 46 56 66 76 86 96", 
            "7 17 27 37 47 57 67 77 87 97", "8 18 28 38 48 58 68 78 88 98", "9 19 29 39 49 59 69 79 89 99", 
            "10 20 30 40 50 60 70 80 90 100"</assert-permutation>
    </result>
  </test-case>
  <test-case name="group-001a"><response-string>(xs:string("1 11 21 31 41 51 61 71 81 91"),xs:string("2 12 22 32 42 52 62 72 82 92"),xs:string("3 13 23 33 43 53 63 73 83 93"),xs:string("4 14 24 34 44 54 64 74 84 94"),xs:string("5 15 25 35 45 55 65 75 85 95"),xs:string("6 16 26 36 46 56 66 76 86 96"),xs:string("7 17 27 37 47 57 67 77 87 97"),xs:string("8 18 28 38 48 58 68 78 88 98"),xs:string("9 19 29 39 49 59 69 79 89 99"),xs:string("10 20 30 40 50 60 70 80 90 100"))</response-string>
    <description>Group atomic values using new syntax agreed Sept 2011</description>
    <created by="Michael Kay" on="2011-09-14"/>
    <test> 
            for $x in 1 to 100 
            group by $key := $x mod 10 
            return string(text{$x})
      </test>
    <result-string>(xs:string("1 11 21 31 41 51 61 71 81 91"),xs:string("2 12 22 32 42 52 62 72 82 92"),xs:string("3 13 23 33 43 53 63 73 83 93"),xs:string("4 14 24 34 44 54 64 74 84 94"),xs:string("5 15 25 35 45 55 65 75 85 95"),xs:string("6 16 26 36 46 56 66 76 86 96"),xs:string("7 17 27 37 47 57 67 77 87 97"),xs:string("8 18 28 38 48 58 68 78 88 98"),xs:string("9 19 29 39 49 59 69 79 89 99"),xs:string("10 20 30 40 50 60 70 80 90 100"))</result-string>
    <result>
      <assert-permutation>"1 11 21 31 41 51 61 71 81 91", "2 12 22 32 42 52 62 72 82 92", "3 13 23 33 43 53 63 73 83 93", 
            "4 14 24 34 44 54 64 74 84 94", "5 15 25 35 45 55 65 75 85 95", "6 16 26 36 46 56 66 76 86 96", 
            "7 17 27 37 47 57 67 77 87 97", "8 18 28 38 48 58 68 78 88 98", "9 19 29 39 49 59 69 79 89 99", 
            "10 20 30 40 50 60 70 80 90 100"</assert-permutation>
    </result>
  </test-case>
  <test-case name="group-002"><response-string>(xs:string("female:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13"),xs:string("male:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"))</response-string>
    <description> Basic grouping test, using nodes as input </description>
    <created by="Michael Kay" on="2008-11-26"/>
    <modified by="Michael Kay" change="correct test and allow permutation of results" on="2011-08-01"/>
    <environment ref="works-mod"/>
    <test> 
            for $x in //employee 
            let $key := $x/@gender 
            group by $key 
            return concat($key, &apos;:&apos;,  
                   string-join(for $e in $x return $e/@name/string(), &apos;,&apos;)) 
      </test>
    <result-string>(xs:string("female:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13"),xs:string("male:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"))</result-string>
    <result>
      <assert-permutation>
            "female:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13",
            "male:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"
         </assert-permutation>
    </result>
  </test-case>
  <test-case name="group-002a"><response-string>(xs:string("female:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13"),xs:string("male:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"))</response-string>
    <description> Basic grouping test, using nodes as input, using new Sept 2011 syntax </description>
    <created by="Michael Kay" on="2011-09-14"/>
    <environment ref="works-mod"/>
    <test> 
            for $x in //employee 
            group by $key := $x/@gender 
            return concat($key, &apos;:&apos;,  
                   string-join(for $e in $x return $e/@name/string(), &apos;,&apos;)) 
      </test>
    <result-string>(xs:string("female:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13"),xs:string("male:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"))</result-string>
    <result>
      <assert-permutation>
            "female:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13",
            "male:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"
         </assert-permutation>
    </result>
  </test-case>
  <test-case name="group-003"><response-string>(xs:string("false:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13"),xs:string("true:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"))</response-string>
    <description> Basic grouping test, using nodes as input, boolean grouping key </description>
    <created by="Michael Kay" on="2008-11-26"/>
    <modified by="Michael Kay" change="correct test and allow permutation of results" on="2011-08-01"/>
    <environment ref="works-mod"/>
    <test> 
            for $x in //employee 
            let $key := ($x/@gender = &apos;male&apos;) 
            group by $key 
            return concat($key, &apos;:&apos;,  
                   string-join(for $e in $x return $e/@name/string(), &apos;,&apos;)) 
      </test>
    <result-string>(xs:string("false:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13"),xs:string("true:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"))</result-string>
    <result>
      <assert-permutation>
            "false:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13",
            "true:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"
         </assert-permutation>
    </result>
  </test-case>
  <test-case name="group-003a"><response-string>(xs:string("false:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13"),xs:string("true:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"))</response-string>
    <description> Basic grouping test, using nodes as input, boolean grouping key;
          using new Sept 2011 syntax</description>
    <created by="Michael Kay" on="2011-09-14"/>
    <environment ref="works-mod"/>
    <test> 
            for $x in //employee 
            group by $key := ($x/@gender = &apos;male&apos;) 
            return concat($key, &apos;:&apos;,  
                   string-join(for $e in $x return $e/@name/string(), &apos;,&apos;)) 
      </test>
    <result-string>(xs:string("false:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13"),xs:string("true:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"))</result-string>
    <result>
      <assert-permutation>
            "false:Jane Doe 1,Jane Doe 3,Jane Doe 5,Jane Doe 7,Jane Doe 9,Jane Doe 11,Jane Doe 13",
            "true:John Doe 2,John Doe 4,John Doe 6,John Doe 8,John Doe 10,John Doe 12"
         </assert-permutation>
    </result>
  </test-case>
  <test-case name="group-004"><response-string>(xs:string("female:41.25"),xs:string("male:37.75"))</response-string>
    <description> Basic grouping test, using nodes as input, aggregate over a group </description>
    <created by="Michael Kay" on="2008-11-26"/>
    <modified by="Michael Kay" change="correct test and allow permutation of results" on="2011-08-01"/>
    <environment ref="works-mod"/>
    <test> 
            for $x in //employee 
            let $key := $x/@gender 
            group by $key 
            return concat($key, &apos;:&apos;, avg($x/hours)) 
      </test>
    <result-string>(xs:string("female:41.25"),xs:string("male:37.75"))</result-string>
    <result>
      <assert-permutation>"female:41.25", "male:37.75"</assert-permutation>
    </result>
  </test-case>
  <test-case name="group-005"><response-string>(&lt;group hours="40" avHours="40"/&gt;,&lt;group hours="70 20" avHours="45"/&gt;,&lt;group hours="80" avHours="80"/&gt;,&lt;group hours="20 40" avHours="30"/&gt;,&lt;group hours="20 30" avHours="25"/&gt;,&lt;group hours="12" avHours="12"/&gt;,&lt;group hours="20" avHours="20"/&gt;)</response-string>
    <description> Basic grouping test, multivalued grouping key, currently an error </description>
    <created by="Michael Kay" on="2008-11-26"/>
    <modified by="Michael Kay" change="correct test; change expected error" on="2011-08-01"/>
    <environment ref="works-mod"/>
    <test>
      <![CDATA[
            for $x in //employee 
            let $key := $x/hours 
            group by $key 
            return <group hours="{$key}" avHours="{avg($x/hours)}"/> 
      ]]>
    </test>
    <result-string>fn:error(fn:QName("http://www.w3.org/2005/xqt-errors", "XPTY0004"))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case name="group-006"><response-string>&lt;out&gt;&lt;group status="" count="12"/&gt;&lt;group status="active" count="1"/&gt;&lt;/out&gt;</response-string>
    <description> A grouping key can be empty </description>
    <created by="Michael Kay" on="2008-11-26"/>
    <modified by="Michael Kay" change="allow permutations of result" on="2011-08-01"/>
    <modified by="Michael Kay" change="use new group-by syntax" on="2011-09-14"/>
    <environment ref="works-mod"/>
    <test>
      <![CDATA[
        <out>{ 
            for $x in //employee 
            group by $key := $x/status 
            return <group status="{$key}" count="{count($x)}"/> 
        }</out>
      ]]>
    </test>
    <result-string>&lt;out&gt;&lt;group status="" count="12"/&gt;&lt;group status="active" count="1"/&gt;&lt;/out&gt;</result-string>
    <result-string>&lt;out&gt;&lt;group status="" count="12"/&gt;&lt;group status="active" count="1"/&gt;&lt;/out&gt;</result-string>
    <result>
      <any-of>
        <assert-xml>
          <![CDATA[<out><group status="" count="12"/><group status="active" count="1"/></out>]]>
        </assert-xml>
        <assert-xml>
          <![CDATA[<out><group status="active" count="1"/><group status="" count="12"/></out>]]>
        </assert-xml>
      </any-of>
    </result>
  </test-case>
  <test-case name="group-007"><response-string>(xs:string("40:3"),xs:string("80:3"),xs:string("20:5"))</response-string>
    <description> Group by with a where clause </description>
    <created by="Michael Kay" on="2008-11-26"/>
    <modified by="Michael Kay" change="allow permutations of result" on="2011-08-01"/>
    <environment ref="works-mod"/>
    <test> 
            for $x in //employee 
            let $key := $x/hours[1] 
            group by $key 
            where count($x) gt 2 
            return concat($key, &apos;:&apos;, count($x)) 
      </test>
    <result-string>(xs:string("40:3"),xs:string("80:3"),xs:string("20:5"))</result-string>
    <result>
      <assert-permutation>"40:3", "80:3", "20:5"</assert-permutation>
    </result>
  </test-case>
  <test-case name="group-008"><response-string>&lt;out&gt;&lt;group count="2"&gt;Jane Doe 7|John Doe 8&lt;/group&gt;&lt;group count="2"&gt;Jane Doe 9|John Doe 10&lt;/group&gt;&lt;group count="3"&gt;Jane Doe 11|John Doe 12|Jane Doe 13&lt;/group&gt;&lt;group count="6"&gt;Jane Doe 1|John Doe 2|Jane Doe 3|John Doe 4|Jane Doe 5|John Doe 6&lt;/group&gt;&lt;/out&gt;</response-string>
    <description> Group by with an order-by clause </description>
    <created by="Michael Kay" on="2008-11-26"/>
    <modified by="Michael Kay" change="make results predictable by adding second order key" on="2011-08-01"/>
    <environment ref="works-mod"/>
    <test>
      <![CDATA[
        <out>{ 
            for $x in //employee 
            let $key := $x/empnum 
            group by $key 
            order by count($x), $key 
            return <group count="{count($x)}"> {string-join($x/@name, '|')} </group> 
        }</out>
      ]]>
    </test>
    <result-string>&lt;out&gt;&lt;group count="2"&gt;Jane Doe 7|John Doe 8&lt;/group&gt;&lt;group count="2"&gt;Jane Doe 9|John Doe 10&lt;/group&gt;&lt;group count="3"&gt;Jane Doe 11|John Doe 12|Jane Doe 13&lt;/group&gt;&lt;group count="6"&gt;Jane Doe 1|John Doe 2|Jane Doe 3|John Doe 4|Jane Doe 5|John Doe 6&lt;/group&gt;&lt;/out&gt;</result-string>
    <result>
      <assert-xml>
        <![CDATA[<out><group count="2">Jane Doe 7|John Doe 8</group><group count="2">Jane Doe 9|John Doe 10</group><group count="3">Jane Doe 11|John Doe 12|Jane Doe 13</group><group count="6">Jane Doe 1|John Doe 2|Jane Doe 3|John Doe 4|Jane Doe 5|John Doe 6</group></out>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="group-009"><response-string>In progress...</response-string>
    <description> Group by with a collation, and with sorting </description>
    <created by="Michael Kay" on="2008-11-26"/>
    <environment ref="works-mod"/>
    <test>
      <![CDATA[
        <out>{ 
            for $x in //employee 
            let $key := $x/empnum 
            group by $key collation "http://www.w3.org/2005/xpath-functions/collation/codepoint" 
            order by $key 
            return <group count="{count($x)}" key="{$key}"> {string-join($x/pnum, '|')} </group> 
        }</out>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<out><group count="6" key="E1">P1|P2|P3|P4|P5|P6</group><group count="2" key="E2">P1|P2</group><group count="2" key="E3">P2|P2</group><group count="3" key="E4">P2|P4|P5</group></out>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="group-009a"><response-string>In progress...</response-string>
    <description> Group by with a collation, and with sorting; using new (Sept 2011) syntax </description>
    <created by="Michael Kay" on="2011-09-14"/>
    <environment ref="works-mod"/>
    <test>
      <![CDATA[
        <out>{ 
            for $x in //employee 
            group by $key := $x/empnum collation "http://www.w3.org/2005/xpath-functions/collation/codepoint" 
            order by $key 
            return <group count="{count($x)}" key="{$key}"> {string-join($x/pnum, '|')} </group> 
        }</out>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<out><group count="6" key="E1">P1|P2|P3|P4|P5|P6</group><group count="2" key="E2">P1|P2</group><group count="2" key="E3">P2|P2</group><group count="3" key="E4">P2|P4|P5</group></out>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="group-010"><response-string>&lt;out&gt;&lt;group key="42" count="1"/&gt;&lt;group key="NaN" count="1"/&gt;&lt;group key="42" count="1"/&gt;&lt;group key="NaN" count="1"/&gt;&lt;group key="42" count="1"/&gt;&lt;group key="NaN" count="1"/&gt;&lt;group key="42" count="1"/&gt;&lt;group key="NaN" count="1"/&gt;&lt;group key="42" count="1"/&gt;&lt;group key="NaN" count="1"/&gt;&lt;group key="42" count="1"/&gt;&lt;group key="NaN" count="1"/&gt;&lt;group key="42" count="1"/&gt;&lt;/out&gt;</response-string>
    <description> NaN values go in the same group </description>
    <created by="Michael Kay" on="2008-11-26"/>
    <environment ref="works-mod"/>
    <test>
      <![CDATA[
        <out>{ 
            for $x in //employee 
            let $key := if ($x/@gender='male') then number('NaN') else 42 
            group by $key 
            return <group key="{$key}" count="{count($x)}"/> 
        }</out>
      ]]>
    </test>
    <result-string/>
    <result-string/>
    <result>
      <any-of>
        <assert-xml>
          <![CDATA[<out><group key="NaN" count="6"/><group key="42" count="7"/></out>]]>
        </assert-xml>
        <assert-xml>
          <![CDATA[<out><group key="42" count="7"/><group key="NaN" count="6"/></out>]]>
        </assert-xml>
      </any-of>
    </result>
  </test-case>
  <test-case name="group-011"><response-string>(xs:string("1 3 5 7 9"),xs:string("2 4 6 8 10"))</response-string>
    <description>Group by with position variable (Bug report on Saxon submitted by Leo W&#246;rteler of BaseX)</description>
    <created by="Michael Kay" on="2011-07-24"/>
    <modified by="Michael Kay" change="correct expected result" on="2011-08-01"/>
    <test>
        for $a at $p in 1 to 10
        let $g := $p mod 2
        group by $g
        return string-join($p!string(), &apos; &apos;)  
     </test>
    <result-string>(xs:string("1 3 5 7 9"),xs:string("2 4 6 8 10"))</result-string>
    <result>
      <assert-permutation>"1 3 5 7 9", "2 4 6 8 10"</assert-permutation>
    </result>
  </test-case>
  <test-case name="group-012"><response-string>&lt;out/&gt;</response-string>
    <description> Grouping of an empty sequence </description>
    <created by="Michael Kay" on="2011-07-24"/>
    <environment ref="works-mod"/>
    <dependency type="spec" value="XQ10+"/>
    <test>
      <![CDATA[
        <out>{ 
            for $x in //employee[age > 300] 
            let $key := @gender 
            group by $key 
            return <group gender="{$key}"> { 
                        for $e in $x return <person>{$e/@name/string()}</person> 
                   } </group> 
        }</out>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<out/>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="group-013"><response-string>In progress...</response-string>
    <description>Grouping by already existing variable</description>
    <created by="Matthias Brantner" on="2012-06-04"/>
    <test>
      <![CDATA[
       for $x in 1 to 10, $y in 1 to 4
       let $org_y := $y
       group by $y, $y := $x mod 2
       return <grp y="{$org_y[1]}" even="{$y}">{$x}</grp>
     ]]>
    </test>
    <result-string/>
    <result-string/>
    <result>
      <any-of>
        <assert-xml>
          <![CDATA[<grp even="1" y="1">1 1 1 1 3 3 3 3 5 5 5 5 7 7 7 7 9 9 9 9</grp><grp even="0" y="1">2 2 2 2 4 4 4 4 6 6 6 6 8 8 8 8 10 10 10 10</grp>]]>
        </assert-xml>
        <assert-xml>
          <![CDATA[<grp even="0" y="1">2 2 2 2 4 4 4 4 6 6 6 6 8 8 8 8 10 10 10 10</grp><grp even="1" y="1">1 1 1 1 3 3 3 3 5 5 5 5 7 7 7 7 9 9 9 9</grp>]]>
        </assert-xml>
      </any-of>
    </result>
  </test-case>
  <test-case name="group-014"><response-string>(xs:integer("1"),xs:integer("2"))</response-string>
    <description>Referenced grouping variable is not in the tuple stream. </description>
    <created by="Josh Spiegel" on="2012-10-02"/>
    <test>
         let $x := 1
         return
           for $i in ("a", "b")
           group by $x
           return
             ($x, count($i))
      </test>
    <result-string>fn:error(fn:QName("http://www.w3.org/2005/xqt-errors", "XQST0094"))</result-string>
    <result>
      <error code="XQST0094"/>
    </result>
  </test-case>
  <test-case name="group-015"><response-string>fn:error(fn:QName("http://www.w3.org/2005/xqt-errors", "err:XPTY0004"))</response-string>
    <description>No value comparisons are available to compare the grouping keys.</description>
    <created by="Josh Spiegel" on="2012-10-02"/>
    <test>
          for $x in (true(), "true", xs:QName("true"))
          group by $x
          return $x
      </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[true true true]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="group-016"><response-string>fn:error(fn:QName("http://www.w3.org/2005/xqt-errors", "err:XPST0003"))</response-string>
    <description>In the first grouping spec, the grouping variable does not reference the generated let binding.  See also group-013 </description>
    <created by="Josh Spiegel" on="2012-10-02"/>
    <test>
       count(
         for $y in 1 to 10
         group by $y := $y, $y := $y mod 2
         return $y
       )
     </test>
    <result-string>xs:integer("2")</result-string>
    <result>
      <assert-eq>2</assert-eq>
    </result>
  </test-case>
  <test-case name="use-case-groupby-Q1"><response-string>&lt;sales-qty-by-product&gt;&lt;product name="blender"&gt;250&lt;/product&gt;&lt;product name="broiler"&gt;20&lt;/product&gt;&lt;product name="shirt"&gt;10&lt;/product&gt;&lt;product name="socks"&gt;510&lt;/product&gt;&lt;product name="toaster"&gt;200&lt;/product&gt;&lt;/sales-qty-by-product&gt;</response-string>
    <description>Use Case "Group By" - Q1</description>
    <created by="Andrew Eisenberg" on="2012-03-14"/>
    <environment ref="GroupByUseCases"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
               <sales-qty-by-product>{
                 for $sales in $sales-records-doc/*/record
                 let $pname := $sales/product-name
                 group by $pname
                 order by $pname
                 return
                   <product name="{$pname}">{
                     sum($sales/qty)
                   }</product>
               }</sales-qty-by-product> 
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<sales-qty-by-product><product name="blender">250</product><product name="broiler">20</product><product name="shirt">10</product><product name="socks">510</product><product name="toaster">200</product></sales-qty-by-product>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="use-case-groupby-Q2"><response-string>In progress...</response-string>
    <description>Use Case "Group By" - Q2</description>
    <created by="Andrew Eisenberg" on="2012-03-14"/>
    <environment ref="GroupByUseCases"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
               <result>{
                 for $sales in $sales-records-doc/*/record
                 let $state := $stores-doc/*/store[store-number = $sales/store-number]/state
                 let $category := $products-doc/*/product[name = $sales/product-name]/category
                 group by $state, $category
                 order by $state, $category
                 return
                   <group>
                     <state>{$state}</state>
                     <category>{$category}</category>
                     <total-qty>{sum($sales/qty)}</total-qty>
                   </group>
               }</result>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<result><group><state>CA</state><category>clothes</category><total-qty>510</total-qty></group><group><state>CA</state><category>kitchen</category><total-qty>170</total-qty></group><group><state>MA</state><category>clothes</category><total-qty>10</total-qty></group><group><state>MA</state><category>kitchen</category><total-qty>300</total-qty></group></result>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="use-case-groupby-Q3"><response-string>In progress...</response-string>
    <description>Use Case "Group By" - Q3</description>
    <created by="Andrew Eisenberg" on="2012-03-14"/>
    <environment ref="GroupByUseCases"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
               <result>{
                 for $sales in $sales-records-doc/*/record
                 let $state := $stores-doc/*/store[store-number = $sales/store-number]/state,
                   $product := $products-doc/*/product[name = $sales/product-name],
                   $category := $product/category,
                   $revenue := $sales/qty * $product/price
                 group by $state, $category
                 order by $state, $category
                 return
                   <group>
                     <state>{$state}</state>
                     <category>{$category}</category>
                     <total-revenue>{sum($revenue)}</total-revenue>
                   </group>
               }</result>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<result><group><state>CA</state><category>clothes</category><total-revenue>2550</total-revenue></group><group><state>CA</state><category>kitchen</category><total-revenue>6500</total-revenue></group><group><state>MA</state><category>clothes</category><total-revenue>100</total-revenue></group><group><state>MA</state><category>kitchen</category><total-revenue>14000</total-revenue></group></result>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="use-case-groupby-Q4"><response-string>&lt;result&gt;&lt;state name="CA"&gt;&lt;category name="clothes"&gt;&lt;product name="socks" total-qty="510"/&gt;&lt;/category&gt;&lt;category name="kitchen"&gt;&lt;product name="broiler" total-qty="20"/&gt;&lt;product name="toaster" total-qty="150"/&gt;&lt;/category&gt;&lt;/state&gt;&lt;state name="MA"&gt;&lt;category name="clothes"&gt;&lt;product name="shirt" total-qty="10"/&gt;&lt;/category&gt;&lt;category name="kitchen"&gt;&lt;product name="blender" total-qty="250"/&gt;&lt;product name="toaster" total-qty="50"/&gt;&lt;/category&gt;&lt;/state&gt;&lt;state name="WA"&gt;&lt;category name="clothes"/&gt;&lt;category name="kitchen"/&gt;&lt;/state&gt;&lt;/result&gt;</response-string>
    <description>Use Case "Group By" - Q4</description>
    <created by="Andrew Eisenberg" on="2012-03-14"/>
    <environment ref="GroupByUseCases"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
               <result>{
                 for $store in $stores-doc/*/store
                 let $state := $store/state
                 group by $state
                 order by $state
                 return
                   <state name="{$state}">{
                     for $product in $products-doc/*/product
                     let $category := $product/category
                     group by $category
                     order by $category
                     return
                       <category name="{$category}">{
                         for $sales in $sales-records-doc/*/record[store-number = $store/store-number
                           and product-name = $product/name]
                         let $pname := $sales/product-name
                         group by $pname
                         order by $pname
                         return
                           <product name="{$pname}" total-qty="{sum($sales/qty)}" />
                         }</category>
                   }</state>
               }</result>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<result><state name="CA"><category name="clothes"><product name="socks" total-qty="510"/></category><category name="kitchen"><product name="broiler" total-qty="20"/><product name="toaster" total-qty="150"/></category></state><state name="MA"><category name="clothes"><product name="shirt" total-qty="10"/></category><category name="kitchen"><product name="blender" total-qty="250"/><product name="toaster" total-qty="50"/></category></state><state name="WA"><category name="clothes"/><category name="kitchen"/></state></result>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="use-case-groupby-Q5"><response-string>&lt;result&gt;&lt;store number="1"&gt;&lt;product name="socks" qty="500"/&gt;&lt;product name="broiler" qty="20"/&gt;&lt;/store&gt;&lt;store number="2"&gt;&lt;product name="toaster" qty="100"/&gt;&lt;product name="toaster" qty="50"/&gt;&lt;product name="socks" qty="10"/&gt;&lt;/store&gt;&lt;store number="3"&gt;&lt;product name="blender" qty="150"/&gt;&lt;product name="blender" qty="100"/&gt;&lt;product name="toaster" qty="50"/&gt;&lt;product name="shirt" qty="10"/&gt;&lt;/store&gt;&lt;/result&gt;</response-string>
    <description>Use Case "Group By" - Q5</description>
    <created by="Andrew Eisenberg" on="2012-03-14"/>
    <environment ref="GroupByUseCases"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
               <result>{
                 for $sales in $sales-records-doc/*/record
                 let $storeno := $sales/store-number
                 group by $storeno
                 order by $storeno
                 return
                   <store number = "{$storeno}">{
                     for $s in $sales
                     order by xs:int($s/qty) descending
                     return
                       <product name = "{$s/product-name}" qty = "{$s/qty}"/>
                   }</store>
               }</result>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<result><store number="1"><product name="socks" qty="500"/><product name="broiler" qty="20"/></store><store number="2"><product name="toaster" qty="100"/><product name="toaster" qty="50"/><product name="socks" qty="10"/></store><store number="3"><product name="blender" qty="150"/><product name="blender" qty="100"/><product name="toaster" qty="50"/><product name="shirt" qty="10"/></store></result>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="use-case-groupby-Q6"><response-string>&lt;result&gt;&lt;store number="3" total-profit="7320"/&gt;&lt;store number="2" total-profit="3030"/&gt;&lt;store number="1" total-profit="2100"/&gt;&lt;/result&gt;</response-string>
    <description>Use Case "Group By" - Q6</description>
    <created by="Andrew Eisenberg" on="2012-03-14"/>
    <environment ref="GroupByUseCases"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
               <result>{
                 for $sales in $sales-records-doc/*/record
                 let $storeno := $sales/store-number,
                   $product := $products-doc/*/product[name = $sales/product-name],
                   $prd := $product,
                   $profit := $sales/qty * ($prd/price - $prd/cost)
                 group by $storeno
                 let $total-store-profit := sum($profit)
                 where $total-store-profit > 100
                 order by $total-store-profit descending
                 return
                   <store number = "{$storeno}" total-profit = "{$total-store-profit}"/>
                }</result>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<result><store number="3" total-profit="7320"/><store number="2" total-profit="3030"/><store number="1" total-profit="2100"/></result>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="use-case-groupby-Q7"><response-string>&lt;result&gt;&lt;author name="Alan Simon"&gt;&lt;title&gt;SQL:1999&lt;/title&gt;&lt;title&gt;Strategic Database Technology&lt;/title&gt;&lt;/author&gt;&lt;author name="Andrew Eisenberg"&gt;&lt;title&gt;Understanding SQL and Java Together&lt;/title&gt;&lt;/author&gt;&lt;author name="Jim Melton"&gt;&lt;title&gt;Advanced SQL:1999&lt;/title&gt;&lt;title&gt;Querying XML&lt;/title&gt;&lt;title&gt;SQL:1999&lt;/title&gt;&lt;title&gt;Understanding SQL and Java Together&lt;/title&gt;&lt;/author&gt;&lt;author name="Stephen Buxton"&gt;&lt;title&gt;Querying XML&lt;/title&gt;&lt;/author&gt;&lt;/result&gt;</response-string>
    <description>Use Case "Group By" - Q7</description>
    <created by="Andrew Eisenberg" on="2012-03-14"/>
    <environment ref="GroupByUseCases"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
               <result>{
                 for $book in $books-doc/*/book
                 for $author in $book/author
                 group by $author
                 order by $author
                 return
                 <author name="{$author}">{
                   for $b in $book
                   order by $b/title
                   return
                     <title> {fn:data($b/title)} </title>
                 }</author>
               }</result>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<result><author name="Alan Simon"><title>SQL:1999</title><title>Strategic Database Technology</title></author><author name="Andrew Eisenberg"><title>Understanding SQL and Java Together</title></author><author name="Jim Melton"><title>Advanced SQL:1999</title><title>Querying XML</title><title>SQL:1999</title><title>Understanding SQL and Java Together</title></author><author name="Stephen Buxton"><title>Querying XML</title></author></result>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case name="use-case-groupby-Q8"><response-string>&lt;result&gt;&lt;author-list names="Alan Simon"&gt;&lt;title&gt;Strategic Database Technology&lt;/title&gt;&lt;/author-list&gt;&lt;author-list names="Jim Melton"&gt;&lt;title&gt;Advanced SQL:1999&lt;/title&gt;&lt;/author-list&gt;&lt;author-list names="Jim Melton, Alan Simon"&gt;&lt;title&gt;SQL:1999&lt;/title&gt;&lt;/author-list&gt;&lt;author-list names="Jim Melton, Andrew Eisenberg"&gt;&lt;title&gt;Understanding SQL and Java Together&lt;/title&gt;&lt;/author-list&gt;&lt;author-list names="Jim Melton, Stephen Buxton"&gt;&lt;title&gt;Querying XML&lt;/title&gt;&lt;/author-list&gt;&lt;/result&gt;</response-string>
    <description>Use Case "Group By" - Q8</description>
    <created by="Andrew Eisenberg" on="2012-03-14"/>
    <environment ref="GroupByUseCases"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
               <result>{
                 for $book in $books-doc/*/book
                 let $author-list := fn:string-join($book/author, ', ')
                 group by $author-list
                 order by $author-list
                 return
                   <author-list names="{$author-list}">{
                     for $b in $book
                     order by $b/title
                     return
                       <title> {fn:data($b/title)} </title>
                   }</author-list>
               }</result>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<result><author-list names="Alan Simon"><title>Strategic Database Technology</title></author-list><author-list names="Jim Melton"><title>Advanced SQL:1999</title></author-list><author-list names="Jim Melton, Alan Simon"><title>SQL:1999</title></author-list><author-list names="Jim Melton, Andrew Eisenberg"><title>Understanding SQL and Java Together</title></author-list><author-list names="Jim Melton, Stephen Buxton"><title>Querying XML</title></author-list></result>]]>
      </assert-xml>
    </result>
  </test-case>
</test-set>