<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="misc-HigherOrderFunctions">
   <description>Tests for features associated with higher order functions</description>
   <link type="spec" document="http://www.w3.org/TR/xquery-30/"
         idref="doc-xquery30-EQName"/>
   <link type="spec" document="XQuery" section-number="H.0.0.0.0.0.0.0" idref="__HOF"/>
   
   <dependency type="feature" value="higherOrderFunctions"/>
   
   <environment name="user-defined-types">
      <schema uri="http://www.w3.org/XQueryTest/userDefinedTypes" file="../docs/userdefined.xsd">
         <description>A schema user defined types and constructor tests</description>
         <created by="Anonymous" on="2006-04-03"/>
      </schema>   
   </environment>        

   <test-case name="hof-001" covers="named-function-ref dynamic-function-call">
      <description> named function reference, user-defined function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
        declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
        let $f := local:f#1 return $f(2)</test>
      <result>
         <assert-eq>3</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-002" covers="named-function-ref dynamic-function-call">
      <description> named function reference, user-defined function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f() as xs:integer { 42 }; 
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := local:f#0 return $f()
      </test>
      <result>
         <assert-eq>42</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-003" covers="named-function-ref dynamic-function-call">
      <description> named function reference, imported user-defined function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <module uri="http://example.com/hof-003" file="HigherOrderFunctions/module-hof-003.xq"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
        import module namespace m="http://example.com/hof-003"; 
        let $f := m:f#1 return $f(17)</test>
      <result>
         <assert-eq>18</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-004" covers="named-function-ref dynamic-function-call">
      <description> named function reference, system function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>let $f := fn:round#1 return $f(1.2345)</test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-005" covers="named-function-ref dynamic-function-call">
      <description> named function reference, system function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>let $f := concat#8 return $f('a','b','c','d','e','f','g','h')</test>
      <result>
         <assert-string-value>abcdefgh</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-006" covers="named-function-ref dynamic-function-call">
      <description> named function reference, user-defined function, default function namespace  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare default function namespace "http://example.com/hof-006"; 
      declare function g($x as xs:integer) as xs:integer { $x + 1 }; 
      let $f := g#1 return $f(21)
      </test>
      <result>
         <assert-eq>22</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-007" covers="named-function-ref dynamic-function-call">
      <description> named function reference, constructor function, default namespace  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare default function namespace "http://www.w3.org/2001/XMLSchema"; 
      let $f := date#1 return $f('2008-01-31')
      </test>
      <result>
         <assert-string-value>2008-01-31</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-008" covers="named-function-ref dynamic-function-call">
      <description> named function reference, constructor function, non default namespace  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>let $f := xs:date#1 return $f('2008-01-31')</test>
      <result>
         <assert-string-value>2008-01-31</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-009" covers="named-function-ref dynamic-function-call">
      <description> named function reference, constructor function, used-defined atomic type  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <environment ref="user-defined-types"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        import schema namespace a = "http://www.w3.org/XQueryTest/userDefinedTypes"; 
        let $f := a:hatsize#1 
        return ($f(8) instance of a:hatsize)
      </test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="hof-010" covers="named-function-ref dynamic-function-call">
      <description> SequenceType function()  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      let $f as function(*) := local:f#1 return $f(2)
      </test>
      <result>
         <assert-eq>3</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-011" covers="named-function-ref dynamic-function-call">
      <description> SequenceType function(x) as z  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:f($x as xs:integer) as xs:integer { $x + 3 }; 
      let $f as function(xs:integer) as xs:integer := local:f#1 
      return $f(2)
      </test>
      <result>
         <assert-eq>5</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-012" covers="named-function-ref dynamic-function-call">
      <description> SequenceType function(x,y) as z  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:f($x as xs:integer, $y as xs:long) as xs:integer { $x + $y }; 
      let $f as function(xs:integer, xs:long) as xs:integer := local:f#2 
      return $f(2, xs:long(5))
      </test>
      <result>
         <assert-eq>7</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-013" covers="named-function-ref dynamic-function-call">
      <description> Selecting from a sequence of functions  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:f($x as xs:integer) as xs:integer { $x + 3 }; 
      declare function local:g($x as xs:integer) as xs:integer { $x + 4 }; 
      declare function local:h($x as xs:integer) as xs:integer { $x + 5 }; 
      let $f as (function(xs:integer) as xs:integer)* := (local:f#1, local:g#1, local:h#1) return $f[3](2)[1]
      </test>
      <result>
         <assert-eq>7</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-014" covers="named-function-ref dynamic-function-call">
      <description> Function returning a function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:case($x as xs:boolean) as function(*) 
      	{ if ($x) then fn:upper-case#1 else fn:lower-case#1 }; 
      local:case(true())("Mike"), local:case(false())("Mike")
      </test>
      <result>
         <assert-string-value>MIKE mike</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-015" covers="named-function-ref dynamic-function-call">
      <description> Function returning a function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:case($x as xs:boolean) as function(xs:string?) as xs:string 
      	{ if ($x) then fn:upper-case#1 else fn:lower-case#1 }; 
      local:case(true())("Mike"), local:case(false())("Mike")</test>
      <result>
         <assert-string-value>MIKE mike</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-016" covers="named-function-ref dynamic-function-call">
      <description> Function expecting a function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:case($x as function(*), $y as xs:string) as xs:string { $x($y) }; 
      local:case(upper-case#1, "Mike"), local:case(lower-case#1, "Mike")
      </test>
      <result>
         <assert-string-value>MIKE mike</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-017" covers="named-function-ref dynamic-function-call">
      <description> Function expecting a function, full signature  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:case($x as function(xs:string?) as xs:string, $y as xs:string) as xs:string { $x($y) }; 
      local:case(upper-case#1, "Mike"), local:case(lower-case#1, "Mike")
      </test>
      <result>
         <assert-string-value>MIKE mike</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-018" covers="named-function-ref dynamic-function-call">
      <description> Function expecting a function, caller supplies local function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string 
      	{ $x($y) }; 
      declare function local:rot13($x as xs:string) as xs:string 
      	{ translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm") }; 
      local:scramble(local:rot13#1, "mike")
      </test>
      <result>
         <assert-string-value>zvxr</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-019" covers="named-function-ref dynamic-function-call">
      <description> Function expecting a function, caller supplies local function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) }; 
      declare function local:rot13($x as xs:string) as xs:string { translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm") }; 
      local:scramble(local:rot13#1, "mike")
      </test>
      <result>
         <assert-string-value>zvxr</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-020" covers="named-function-ref dynamic-function-call">
      <description> Function expecting a function, caller supplies inline function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) }; 
      local:scramble(function($x){translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm")}, "john")
      </test>
      <result>
         <assert-string-value>wbua</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-021" covers="function-item-coercion">
      <description> Function expecting a function, caller supplies inline function. Needs function coercion  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) }; 
      local:scramble(function($x){translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm")}, "john")
      </test>
      <result>
         <assert-string-value>wbua</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-022" covers="fn-function-name fn-function-arity">
      <description> Name and arity of a user-defined function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) }; 
      let $n := function-name(local:scramble#2) 
      return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity(local:scramble#2))
      </test>
      <result>
         <assert-string-value>scramble http://www.w3.org/2005/xquery-local-functions 2</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-023" covers="fn-function-name fn-function-arity">
      <description> Name and arity of a system function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>
        let $f := fn:function-name#1, $n := function-name($f) 
        return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))</test>
      <result>
         <assert-string-value>function-name http://www.w3.org/2005/xpath-functions 1</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-024" covers="fn-function-name fn-function-arity">
      <description> Name and arity of a constructor function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>
        let $f := xs:dateTime#1, $n := function-name($f) 
        return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))</test>
      <result>
         <assert-string-value>dateTime http://www.w3.org/2001/XMLSchema 1</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-025" covers="fn-function-name fn-function-arity">
      <description> Name and arity of a concat function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>let $f := concat#123456, $n := function-name($f) 
        return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))</test>
      <result>
         <assert-string-value>concat http://www.w3.org/2005/xpath-functions 123456</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-026" covers="fn-function-name fn-function-arity inline-function">
      <description> Name and arity of an inline function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        let $f := function($x as xs:string) as xs:string { upper-case($x) } 
        let $n := function-name($f) 
        return <a loc="{local-name-from-QName($n)}" uri="{namespace-uri-from-QName($n)}"
        			arity="{function-arity($f)}" eloc="{empty(local-name-from-QName($n))}" euri="{empty(namespace-uri-from-QName($n))}"/>
      ]]></test>
      <result>
         <assert-xml><![CDATA[<a uri="" loc="" euri="true" eloc="true" arity="1"/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="hof-027" covers="partial-function-application dynamic-function-call">
      <description> Curry a system function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>
        let $f := fn:contains(?, "e") 
        return for $s in ("Mike", "John", "Dave", "Mary", "Jane") return $f($s)</test>
      <result>
         <assert-string-value>true false true false true</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-028" covers="function-item-coercion dynamic-function-call">
      <description> Return an inline function from a user-defined function. Needs function coercion  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:splitter() as (function(xs:string) as xs:string*) { function($x as xs:string) { tokenize($x, '\s') } }; 
      string-join(local:splitter()("A nice cup of tea"), '|')
      </test>
      <result>
         <assert-string-value>A|nice|cup|of|tea</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-029" covers="function-item-coercion dynamic-function-call">
      <description> Return an inline function that uses internal variables. Needs function coercion  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:splitter() as (function(xs:string) as xs:string+)? 
      { function($x as xs:string) { for $i in tokenize($x, '\s') return upper-case($i)} }; 
      string-join(local:splitter()("A nice cup of tea"), '|')
      </test>
      <result>
         <assert-string-value>A|NICE|CUP|OF|TEA</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-030" covers="inline-function dynamic-function-call">
      <description> Return an inline function that uses global variables  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare variable $sep as xs:string := "\s"; 
      declare function local:splitter() as (function(xs:string) as xs:string*)? 
      	{ function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} }; 
      string-join(local:splitter()("A nice cup of tea"), '|')
      </test>
      <result>
         <assert-string-value>A|NICE|CUP|OF|TEA</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-031" covers="inline-function dynamic-function-call">
      <description> Return an inline function that uses local parameters  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:splitter($sep as xs:string) as (function(xs:string) as xs:string*) 
      	{ function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} }; 
      string-join(local:splitter("\s")("A nice cup of tea"), '|')
      </test>
      <result>
         <assert-string-value>A|NICE|CUP|OF|TEA</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-032" covers="dynamic-function-call">
      <description> Parenthesized expression in a function call  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>(if (current-date() gt xs:date('2000-12-31')) then upper-case#1 else lower-case#1)("Mike")</test>
      <result>
         <assert-string-value>MIKE</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-033" covers="fn-function-name dynamic-function-call">
      <description> Context item is a function item  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>local-name-from-QName(function-name((upper-case#1, lower-case#1)[.("Mike") = "MIKE"]))</test>
      <result>
         <assert-string-value>upper-case</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-034" covers="named-function-ref dynamic-function-call">
      <description> ordered{} applied to a function item  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered{.}("Mike") = "MIKE"]))</test>
      <result>
         <assert-string-value>upper-case</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-035" covers="named-function-ref dynamic-function-call">
      <description> unordered{} applied to a function item  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered{.}("Mike") = "MIKE"]))</test>
      <result>
         <assert-string-value>upper-case</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-036" covers="named-function-ref">
      <description> Heterogeneous sequence of atomics and functions on rhs of "/"   </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[(<a b="3"/>/(string(@b), upper-case#1, 17))[. instance of xs:anyAtomicType]]]></test>
      <result>
         <assert-string-value>3 17</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-037" covers="named-function-ref">
      <description> instance-of tests on user-defined function, varying the argument types - all true  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        declare function local:f($x as xs:long, $y as xs:NCName) as element(e) { 
            <e x="{$x}" y="{$y}"/> 
        }; 
        local:f#2 instance of function(*), 
        local:f#2 instance of function(xs:long, xs:NCName) as element(e), 
        local:f#2 instance of function(xs:anyAtomicType?, xs:anyAtomicType?) as element(e), 
        local:f#2 instance of function(item()*, item()*) as element(e)
      ]]></test>
      <result>
         <assert-string-value>true true false false</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-038" covers="named-function-ref">
      <description> instance-of tests on user-defined function, varying the argument types - all false  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        declare function local:f($x as xs:long?, $y as xs:NCName?) as element(e) { 
            <e x="{$x}" y="{$y}"/> 
        }; 
        local:f#2 instance of function(xs:int?, xs:NCName?) as element(e), 
        local:f#2 instance of function(xs:long?) as element(e), 
        local:f#2 instance of function(xs:long?, xs:NCName?, item()*) as element(e), 
        local:f#2 instance of function(xs:long, xs:anyAtomicType?) as element(e), 
        local:f#2 instance of function(item()+, item()+) as element(e)
      ]]></test>
      <result>
         <assert-string-value>true false false false false</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-039" covers="named-function-ref">
      <description> instance-of tests on user-defined function, varying the result types  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <modified by="O'Neil Delpratt" on="2012-10-01" change="Related to bug issue #15999" />
      <modified by="Tim Mills" on="2013-02-26" change="Reflect resolution of bug #15999" />
      <modified by="Michael Kay" on="2013-03-05" change="There are now six results for the six sub-tests (was: 8 results for 6 tests)" />
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
      	declare function local:f($x as xs:long, $y as xs:NCName) as element(e)? { <e x="{$x}" y="{$y}"/> }; 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType?)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?
      ]]></test>
      <result>
         <assert-string-value>true true true true true false</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-040" covers="function-item-coercion">
      <description> Pass a sequence of functions that require coercion in different ways  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* { for $f in $fns return $f($s) }; 
      let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) 
      return string-join(local:apply($ops, 'Michael Kay'), '~')
      </test>
      <result>
         <assert-string-value>MICHAEL KAY~michael kay~Michail Kay~Michael</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-041" covers="partial-function-application function-item-coercion">
      <description> Return a sequence of functions that require coercion in different ways  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:ops() as (function(xs:string) as xs:string)*
      	{ (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) }; 
      string-join(for $f in local:ops() return $f('Michael Kay'), '~')
      </test>
      <result>
         <assert-string-value>MICHAEL KAY~michael kay~Michail Kay~Michael</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-042" covers="partial-function-application">
      <description> Implicit atomization works for various kinds of functions  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        declare function local:lower-case($x as xs:string) as xs:string { concat("'", fn:lower-case($x), "'") }; 
        declare function local:ops() as (function(xs:string) as xs:string)* 
        	{ (upper-case#1, local:lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) }; 
        string-join(for $f in local:ops() return $f(<a name="Michael Kay"/>/@name), '~')
      ]]></test>
      <result>
         <assert-string-value>MICHAEL KAY~'michael kay'~Michail Kay~Michael</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-043" covers="partial-function-application">
      <description> untypedAtomic conversion works for various kinds of functions  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:round($x as xs:double) as xs:double 
      	{ fn:floor($x) }; 
      declare function local:ops() as (function(xs:double) as xs:double)* 
      	{ (abs#1, local:round#1, function($x){$x+1}, round-half-to-even(?, 2)) }; 
      string-join(for $f in local:ops() return string($f(xs:untypedAtomic('123.456'))), '~')
      </test>
      <result>
         <assert-string-value>123.456~123~124.456~123.46</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-044" covers="named-function-ref">
      <description> numeric promotion works for various kinds of functions  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <modified by="Michael Kay" on="2011-01-03" change="see bug #15402"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:round($x as xs:double) as xs:double { fn:floor($x) }; 
      declare function local:ops() as (function(xs:double) as xs:double)* 
      	{ (abs#1, local:round#1, function($x as xs:double){$x+1}, round-half-to-even(?, 2)) }; 
      string-join(for $f in local:ops() return string(round-half-to-even($f(xs:decimal('123.456')), 4)), '~')
      </test>
      <result>
         <assert-string-value>123.456~123~124.456~123.46</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-045" covers="partial-function-application">
      <description>partial-apply supplying a function parameter </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double { $algorithm($x) }; 
      declare variable $roundToCeiling := local:round(?, ceiling#1); $roundToCeiling(12.4)</test>
      <result>
         <assert-eq>13</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-046" covers="inline-function">
      <description>Return an inline function that uses inner and outer local variables</description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        declare function local:splitter($x as xs:string) as (function() as xs:string*)* { 
            for $sep in ('\s', ',', '!') 
            return function() { for $i in tokenize($x, $sep) return upper-case($i) } 
        }; 
        <out>{ 
            for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.") 
            return <tokens>{ for $t in $f() 
                             return <t>{$t}</t> 
                   }</tokens> 
       }</out>
    ]]></test>
      <result>
         <assert-xml><![CDATA[<out><tokens><t>HOW</t><t>NICE!</t><t>THANK</t><t>YOU,</t><t>I</t><t>ENJOYED</t><t>THAT.</t></tokens><tokens><t>HOW NICE! THANK YOU</t><t> I ENJOYED THAT.</t></tokens><tokens><t>HOW NICE</t><t> THANK YOU, I ENJOYED THAT.</t></tokens></out>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="hof-047" covers="inline-function dynamic-function-call">
      <description> Nested inline functions referencing grandfather local variables </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        declare function local:splitter($x as xs:string) as (function() as xs:string*)* { 
            for $sep in ('\s', ',', '!') return function() { 
                for $i in tokenize($x, $sep) return 
                    let $f := function(){ concat($sep, ':', upper-case($i)) } 
                    return $f() } 
        }; 
        <out>{ 
            for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.") 
            return <tokens>{ for $t in $f() 
                             return <t>{$t}</t> }</tokens> 
        }</out>
     ]]></test>
      <result>
         <assert-xml><![CDATA[<out><tokens><t>\s:HOW</t><t>\s:NICE!</t><t>\s:THANK</t><t>\s:YOU,</t><t>\s:I</t><t>\s:ENJOYED</t><t>\s:THAT.</t></tokens><tokens><t>,:HOW NICE! THANK YOU</t><t>,: I ENJOYED THAT.</t></tokens><tokens><t>!:HOW NICE</t><t>!: THANK YOU, I ENJOYED THAT.</t></tokens></out>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="hof-048" covers="named-function-ref forwards-references">
      <description> Forwards reference to a literal function item  </description>
      <created by="Michael Kay" on="2010-08-14"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
        declare function local:do() as xs:integer { (local:f#1)(5) }; 
        declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
        local:do()</test>
      <result>
         <assert-eq>6</assert-eq>
      </result>
   </test-case>

   <test-case name="hof-049" covers="named-function-ref">
      <description> true#0 and false# as literal function items  </description>
      <created by="Michael Kay" on="2011-01-12"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        declare function local:tf($i as xs:integer) as function () as xs:boolean { 
            if ($i) then true#0 else false#0 
        }; 
        <out>{(local:tf(0)(), local:tf(1)())}</out>
      ]]></test>
      <result>
         <assert-xml><![CDATA[<out>false true</out>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="hof-050" covers="named-function-ref partial-function-application">
      <description> Partial application of a literal function item  </description>
      <created by="Michael Kay" on="2011-06-20"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[let $f := fn:substring-before#2(?, '-') return <out>{$f('the-end-of-the-world')}</out>]]></test>
      <result>
         <assert-xml><![CDATA[<out>the</out>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="hof-051" covers="inline-function partial-function-application">
      <description> Partial application of an inline function item  </description>
      <created by="Michael Kay" on="2011-06-20"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        let $f := function($a as xs:string, $b as xs:string) { 
            starts-with($a, $b) and ends-with($a, $b)}(?, 'a') 
        return <out>{$f('abracadabra')}</out>]]></test>
      <result>
         <assert-xml><![CDATA[<out>true</out>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="hof-052" covers="partial-function-application">
      <description> Repeated partial application of a function  </description>
      <created by="Michael Kay" on="2011-06-20"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[let $f := fn:concat#3(?, '*', ?) let $g := $f('[', ?) return <out>{$g(']')}</out>]]></test>
      <result>
         <assert-xml><![CDATA[<out>[*]</out>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="hof-053" covers="named-function-ref">
      <description> instance-of tests on user-defined function, varying the result types  </description>
      <created by="Tim Mills" on="2013-02-26"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
      	declare function local:f($x as xs:long, $y as xs:NCName) as element(e, xs:anyAtomicType) { <e x="{$x}" y="{$y}"/> }; 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(), 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()+, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType?)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType)?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?
      ]]></test>
      <result>
         <assert-string-value>true true true true true true true true true false</assert-string-value>
      </result>
   </test-case>

   <test-case name="hof-901" covers="named-function-ref dynamic-function-call">
      <description> inline function literal, unknown user-defined function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := local:g#1 return $f(2)</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="hof-902" covers="named-function-ref dynamic-function-call">
      <description> inline function literal, unknown user-defined function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := local:f#3 return $f(2)
      </test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="hof-903" covers="named-function-ref dynamic-function-call">
      <description> inline function literal, unknown function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := xs:date#2 return $f('2008-03-01')
      </test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="hof-904" covers="named-function-ref dynamic-function-call">
      <description> inline function literal, unknown function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := concat#1 return $f('2008-03-01')
      </test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="hof-905" covers="named-function-ref">
      <description> apply string() to a function item  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	string(local:f#1)
      </test>
      <result>
         <error code="FOTY0014"/>
      </result>
   </test-case>

   <test-case name="hof-906" covers="named-function-ref">
      <description> apply data() to a function item  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	exists(data(local:f#1))
      </test>
      <result>
         <error code="FOTY0013"/>
      </result>
   </test-case>

   <test-case name="hof-907" covers="named-function-ref">
      <description> apply deep-equal() to a function item  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	deep-equal((1,2,3,4,local:f#1), (1,2,3,4,local:f#1))
      </test>
      <result>
         <error code="FOTY0015"/>
      </result>
   </test-case>

   <test-case name="hof-908" covers="named-function-ref">
      <description> atomize a function item implicitly  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	local:f#1 eq 3
      </test>
      <result>
         <error code="FOTY0013"/>
      </result>
   </test-case>

   <test-case name="hof-909" covers="named-function-ref">
      <description> atomize a function item implicitly  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	number(local:f#1)
      </test>
      <result>
         <error code="FOTY0013"/>
      </result>
   </test-case>

   <test-case name="hof-910" covers="named-function-ref dynamic-function-call">
      <description> In SequenceType syntax, Result type required if argument type given  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
        declare function local:f($x as xs:integer) as xs:integer {
            $x + 1
        };
        let $f as function(xs:integer) := local:f#1
        return $f(3)
      </test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="hof-911" covers="named-function-ref">
      <description> Heterogeneous sequence on rhs of "/" </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[<a b="3"/>/(@b, upper-case#1)]]></test>
      <result>
         <error code="XPTY0018"/>
      </result>
   </test-case>

   <test-case name="hof-912" covers="inline-function partial-function-application">
      <description> Pass a sequence of functions that cannot be coerced to the required type  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
        declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* 
        { for $f in $fns return $f($s) };
        let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, 
            substring-before(?, ' ', ?)) 
        return string-join(local:apply($ops, 'Michael Kay'), '~')</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="hof-913" covers="inline-function">
      <description> Pass a sequence of functions that cannot be coerced to the required type  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
        declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* 
        { for $f in $fns return $f($s) }; 
        let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, 
            string-length#1) 
        return string-join(local:apply($ops, 'Michael Kay'), '~')</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="hof-914" covers="inline-function">
      <description> Pass a sequence of functions that cannot be coerced to the required type  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
        declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* 
        { for $f in $fns return $f($s) }; 
        let $ops := (upper-case#1, lower-case#1, function($x as xs:double){string($x)}) 
        return string-join(local:apply($ops, 'Michael Kay'), '~')</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="hof-915" covers="partial-function-application">
      <description> partial-apply, argument number out of range  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>let $ops := substring-before('abc', ' ', (), ?) return $ops('Michael Kay')</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="hof-916" covers="partial-function-application">
      <description> partial-apply, argument number out of range  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>let $ops := substring-before(?, ?) return $ops('Michael Kay')</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="hof-917" covers="partial-function-application">
      <description> partial-apply, argument value invalid for target function  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>let $ops := substring-before(?, 2) return $ops('Michael Kay')</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="hof-918" covers="partial-function-application">
      <description> partial-apply supplying an incorrect function parameter  </description>
      <created by="Michael Kay" on="2009-03-01"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
        declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double 
        { $algorithm($x) }; 
        declare variable $roundToCeiling := local:round(?, upper-case#1); 
        $roundToCeiling(12.4)
      </test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="hof-919" covers="partial-function-application">
      <description> Was hof-044: test that numeric promotion works for various kinds of functions. But there's
      an error - the function item function($x as xs:float){$x+1} doesn't satisfy the required type
      (function(xs:double) as xs:double) because it doesn't accept a double as an argument.
      </description>
      <created by="Michael Kay" on="2012-01-03"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
      declare function local:round($x as xs:double) as xs:double { fn:floor($x) }; 
      declare function local:ops() as (function(xs:double) as xs:double)* 
      	{ (abs#1, local:round#1, function($x as xs:float){$x+1}, round-half-to-even(?, 2)) }; 
      string-join(for $f in local:ops() return string(round-half-to-even($f(xs:decimal('123.456')), 4)), '~')
      </test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <!-- XDM 3.0 function item data type -->

   <test-case name="function-item-1" covers="named-function-ref">
      <description>A function item is a value that represents a function.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>concat#64 instance of function(*)</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="function-item-2" covers="named-function-ref">
      <description>Function items can be invoked, which is the act of calling the function that the function item represents.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>string-join#1(("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"))</test>
      <result>
         <assert-string-value>abcdefghij</assert-string-value>
      </result>
   </test-case>

   <test-case name="function-item-3" covers="named-function-ref">
      <description>Function items have no identity, cannot be compared, and have no serialization.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>string-join#1 is string-join#1</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="function-item-4" covers="named-function-ref">
      <description>Function items have no identity, cannot be compared, and have no serialization.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>string-join#1 eq string-join#1</test>
      <result>
         <error code="FOTY0013"/>
      </result>
   </test-case>

   <test-case name="function-item-5" covers="named-function-ref">
      <description>Function items have no identity, cannot be compared, and have no serialization.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XQ30+"/>
      <test>element a { avg#1 }</test>
      <result>
         <error code="XQTY0105"/>
      </result>
   </test-case>

   <test-case name="function-item-6" covers="named-function-ref">
      <description>Function items have no identity, cannot be compared, and have no serialization.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XQ30+"/>
      <test>attribute a { avg#1 }</test>
      <result>
         <error code="FOTY0013"/>
      </result>
   </test-case>

   <test-case name="function-item-7" covers="inline-function">
      <description>A function item consists of the following information: The set of variable values for the variables referenced by the function.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>(let $a := 92, $b := true() return function($c) { $a, $b, $c })("lala")</test>
      <result>
        <assert-deep-eq>92, true(), "lala"</assert-deep-eq>
      </result>
   </test-case>

   <test-case name="function-item-8" covers="fn-function-name">
      <description>A function item consists of the following information: The name of the function as a xs:QName.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function-name(function-name#1)</test>
      <result>
        <assert-eq>xs:QName("fn:function-name")</assert-eq>
      </result>
   </test-case>

   <test-case name="function-item-9" covers="inline-function fn-function-name">
      <description>A function item consists of the following information: The name of the function as a xs:QName. This is potentially absent.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function-name(let $a := 92, $b := true() return function($c) { $a, $b, $c })</test>
      <result>
        <assert-count>0</assert-count>
      </result>
   </test-case>

   <test-case name="function-item-10" covers="inline-function">
      <description>A function item consists of the following information: The signature of the function item.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>(let $a := 92, $b := true() return function($c) { $a, $b, $c }) instance of function(item()*) as item()*</test>
      <result>
        <assert-true/>
      </result>
   </test-case>

   <test-case name="function-item-11" covers="inline-function">
      <description>A function item consists of the following information: The function implementation.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>(let $a := 92, $b := true() return function($c) { $a, $b, $c })((xs:QName("foo"), 5.0e3))</test>
      <result>
        <assert-deep-eq>92, true(), fn:QName("","foo"), 5000</assert-deep-eq>
      </result>
   </test-case>

   <test-case name="function-item-12" covers="inline-function">
      <description>function(item()) as item() is a subtype of function(*)</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as item()) as item() { $a } instance of function(*)</test>
      <result>
        <assert-true/>
      </result>
   </test-case>

   <test-case name="function-item-13" covers="inline-function">
      <description>function(item()) as xs:integer is a subtype of function(item()) as item()</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as item()) as xs:integer { $a } instance of function(item()) as item()</test>
      <result>
        <assert-true/>
      </result>
   </test-case>

   <test-case name="function-item-14" covers="inline-function">
      <description>function(xs:string) as item() is a subtype of function(item()) as item()</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as item()) as item() { $a } instance of function(xs:string) as item()</test>
      <result>
        <assert-true/>
      </result>
   </test-case>

   <test-case name="function-item-15" covers="inline-function">
      <description>function(item()) as item() is not a subtype of function() as item()</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as item()) as item() { $a } instance of function() as item()</test>
      <result>
        <assert-false/>
      </result>
   </test-case>

   <test-case name="function-item-16" covers="inline-function">
      <description>function(item()) as xs:integer is no a subtype of function(item(), item()) as item()</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as item()) as xs:integer { $a } instance of function(item(), item()) as item()</test>
      <result>
        <assert-false/>
      </result>
   </test-case>

   <test-case name="function-item-17" covers="inline-function">
      <description>function(item()) as item() is not a subtype of function(xs:string) as item()</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as xs:string) as item() { $a } instance of function(item()) as item()</test>
      <result>
        <assert-false/>
      </result>
   </test-case>

   <!-- XQuery 3.0 Inline functions (3.1.7 Inline Functions) -->

   <test-case name="inline-function-1" covers="inline-function">
      <description>An inline function expression creates a function</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function() { 5 } instance of function(*)</test>
      <result>
        <assert-true/>
      </result>
   </test-case>

   <test-case name="inline-function-2" covers="inline-function">
      <description>that represents an anonymous function</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function-name(function() { 5 })</test>
      <result>
        <assert-count>0</assert-count>
      </result>
   </test-case>

   <test-case name="inline-function-3" covers="inline-function">
      <description>An inline function specifies the names and SequenceTypes of the parameters to the function, the SequenceType of the result, and the body of the function.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function() as xs:integer { 5 }()</test>
      <result>
        <assert-eq>5</assert-eq>
      </result>
   </test-case>

   <test-case name="inline-function-4" covers="inline-function">
      <description>An inline function specifies the names and SequenceTypes of the parameters to the function, the SequenceType of the result, and the body of the function.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as xs:integer) as xs:integer { $a + 5 }(3)</test>
      <result>
        <assert-eq>8</assert-eq>
      </result>
   </test-case>

   <test-case name="inline-function-5" covers="inline-function">
      <description>An inline function specifies the names and SequenceTypes of the parameters to the function, the SequenceType of the result, and the body of the function.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as xs:integer, $b as xs:double) as xs:double { $a * $b + 5 }(3, 2)</test>
      <result>
        <assert-eq>11</assert-eq>
      </result>
   </test-case>

   <test-case name="inline-function-6" covers="inline-function">
      <description>If a function parameter is declared using a name but no type, its default type is item()*.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a, $b as xs:double) as xs:double { $a * $b + 5 } instance of function(item()*, xs:double) as xs:double</test>
      <result>
        <assert-true/>
      </result>
   </test-case>

   <test-case name="inline-function-7" covers="inline-function">
      <description>If a function parameter is declared using a name but no type, its default type is item()*.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as node()+, $b) as xs:double { $a * $b + 5 } instance of function(node(), item()*) as xs:double</test>
      <result>
        <assert-true/>
      </result>
   </test-case>

   <test-case name="inline-function-8" covers="inline-function">
      <description>If the result type is omitted from a function declaration, its default result type is item()*.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a as node()+) { $a + 5 } instance of function(node()) as item()*</test>
      <result>
        <assert-true/>
      </result>
   </test-case>

   <test-case name="inline-function-9" covers="inline-function">
      <description>If the result type is omitted from a function declaration, its default result type is item()*.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function() { true() } instance of function() as item()*</test>
      <result>
        <assert-true/>
      </result>
   </test-case>

   <test-case name="inline-function-10" covers="inline-function">
      <description>The parameters of a function declaration are considered to be variables whose scope is the function body.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a) { "lala", $a }, $a</test>
      <result>
        <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="inline-function-11" covers="inline-function">
      <description>The parameters of a function declaration are considered to be variables whose scope is the function body.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>let $a := "monkey" return function($a) { "lala", $a }("gibbon")</test>
      <result>
        <assert-deep-eq>"lala", "gibbon"</assert-deep-eq>
      </result>
   </test-case>

   <test-case name="inline-function-12" covers="inline-function">
      <description>The parameters of a function declaration are considered to be variables whose scope is the function body.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>$a, function($a) { "lala", $a }</test>
      <result>
        <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="inline-function-11a" covers="inline-function">
      <description>The parameters of a function declaration are considered to be variables whose scope is the function body.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <modified by="O'Neil Delpratt" on="2011-10-13" change="test case name already used, Bug #14453. Fixed by added 'a' to the test name"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a) { let $a := "monkey" return ("lala", $a) }("gibbon")</test>
      <result>
        <assert-deep-eq>"lala", "monkey"</assert-deep-eq>
      </result>
   </test-case>

   <test-case name="inline-function-12a" covers="inline-function">
      <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <modified by="O'Neil Delpratt" on="2011-10-13" change="test case name already used, Bug #14453. Fixed by added 'a' to the test name"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($a, $a) { "lala", $a }("gibbon", "monkey")</test>
      <result>
        <error code="XQST0039"/>
      </result>
   </test-case>

   <test-case name="inline-function-13" covers="inline-function">
      <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <modified by="Michael Kay" on="2013-04-05" change="Invalid as an XPath 3.0 test (prefix undeclared). Replaced with -15"/>
      <dependency type="spec" value="XQ30+"/>
      <test>function($local:foo, $local:bar, $local:foo) { "lala", $local:foo, $local:bar }("gibbon", "monkey", "ape")</test>
      <result>
        <error code="XQST0039"/>
      </result>
   </test-case>

   <test-case name="inline-function-14" covers="inline-function">
      <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
      <created by="John Snelson" on="2011-07-28"/>
      <modified by="Michael Kay" on="2013-04-05" change="Invalid as an XPath 3.0 test (prefix undeclared). Replaced with -16"/>
      <dependency type="spec" value="XQ30+"/>
      <test>function($local:foo, $local:bar, $fn:foo) { "lala", $local:foo, $local:bar }("gibbon", "monkey", "ape")</test>
      <result>
        <assert-deep-eq>"lala", "gibbon", "monkey"</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="inline-function-15" covers="inline-function">
      <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
      <created by="Michael Kay" on="2013-04-05"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($Q{http://local/}foo, $Q{http://local/}bar, $Q{http://local/}foo) { 
              "lala", $Q{http://local/}foo, $Q{http://local/}bar }("gibbon", "monkey", "ape")</test>
      <result>
        <error code="XQST0039"/>
      </result>
   </test-case>

   <test-case name="inline-function-16" covers="inline-function">
      <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
      <created by="Michael Kay" on="2013-04-05"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>function($Q{http://local/}foo, $Q{http://local/}bar, $fn:foo) { 
               "lala", $Q{http://local/}foo, $Q{http://local/}bar }("gibbon", "monkey", "ape")</test>
      <result>
        <assert-deep-eq>"lala", "gibbon", "monkey"</assert-deep-eq>
      </result>
   </test-case>
   

<!--The static context for the function body is inherited from the location of the inline function expression, with the exception of the static type of the context item which is initially undefined.-->

   <!-- XQuery 3.0 Literal function items -->

   <!-- XQuery 3.0 Function items -->

   <!-- XQilla HOF tests -->

   <test-case name="xqhof1" covers="dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
declare namespace map = "http://snelson.org.uk/functions/map";

declare function map:key($pair as function() as item()+) as item()
{
  $pair()[1]
};

declare function map:value($pair as function() as item()+) as item()*
{
  subsequence($pair(), 2)
};

declare function map:contains($map as (function() as item()+)*, $key as item())
  as xs:boolean
{
  map:process($map, $key, function($a) { true() }, false(),
    function($a) { () })
};

declare function map:get($map as (function() as item()+)*, $key as item())
  as item()*
{
  map:process($map, $key, map:value#1, (), function($a) { () })
};

declare function map:process(
  $map as (function() as item()+)*,
  $key as item(),
  $found as function(function() as item()+) as item()*,
  $notfound as item()*,
  $unused as function((function() as item()+)*) as item()*
) as item()*
{
  if(empty($map)) then $notfound
  else

  let $length := count($map)
  let $middle := $length idiv 2 + 1
  let $pair := $map[$middle]
  let $pair_key := $pair()[1]
  return
    if($pair_key eq $key) then (
      $unused(subsequence($map, 1, $middle - 1)),
      $found($pair),
      $unused(subsequence($map, $middle + 1))
    )
    else if($pair_key gt $key) then (
      map:process(subsequence($map, 1, $middle - 1), $key,
        $found, $notfound, $unused),
      $unused(subsequence($map, $middle))
    )
    else (
      $unused(subsequence($map, 1, $middle)),
      map:process(subsequence($map, $middle + 1), $key,
        $found, $notfound, $unused)
    )
};

declare function map:pair($key as item(), $value as item()*)
  as function() as item()+
{
  function() { $key, $value }
};

declare function map:put(
  $map as (function() as item()+)*,
  $key as item(),
  $value as item()*
) as (function() as item()+)+
{
  let $pair := map:pair($key, $value)
  return
    map:process($map, $key, function($a) { $pair }, $pair,
      function($a) { $a })
};

string-join(let $map := map:put(map:put(map:put(map:put(map:put(map:put((),
  "a", "aardvark"),
  "z", "zebra"),
  "e", ("elephant", "eagle")),
  "o", "osterich"),
  "t", "terrapin"),
  "a", "antelope")
return (
  map:get($map, "o"),

  for $m in $map
  return concat("key: ", map:key($m), ", value: (",
    string-join(map:value($m), ", "), ")"))
, "&#10;")
</test>
      <result>
         <assert-eq>"osterich
key: a, value: (antelope)
key: e, value: (elephant, eagle)
key: o, value: (osterich)
key: t, value: (terrapin)
key: z, value: (zebra)"</assert-eq>
      </result>
   </test-case>

   <test-case name="xqhof2" covers="dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <module uri="http://snelson.org.uk/functions/functional" file="HigherOrderFunctions/functional.xq"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
         import module namespace func = "http://snelson.org.uk/functions/functional";
         
         let $f := func:curry(concat#5)
         return $f("foo")(" bar")(" baz")(" what's")(" next?")
      </test>
      <result>
         <assert-eq>"foo bar baz what's next?"</assert-eq>
      </result>
   </test-case>

   <test-case name="xqhof3" covers="dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <modified by="John Snelson" on="2013-05-20" change="Spec change to map-pairs arguments. See Action item A-538-06" />
      <module uri="http://snelson.org.uk/functions/functional" file="HigherOrderFunctions/functional.xq"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
import module namespace func = "http://snelson.org.uk/functions/functional";

declare function local:fib2_aux($result as xs:integer, $next as xs:integer, $n) as xs:integer*
{
  if($n eq 0) then () else (
  $result, local:fib2_aux($next, $next + $result, $n - 1))
};

declare function local:fib2($n) as xs:integer*
{
  local:fib2_aux(0, 1, $n)
};

declare function local:map-pairs($f,$a,$b)
{
  for-each-pair($a,$b,$f)
};

string-join(
for $a in subsequence(

let $interleave := func:curry(local:map-pairs#3)(function($a, $b) { $a, $b })
let $enumerate := $interleave(0 to 49)
return
$enumerate(local:fib2(50))

, 1, 100)
return string($a)
, "&#10;")
      </test>
      <result>
         <assert-eq>"0
0
1
1
2
1
3
2
4
3
5
5
6
8
7
13
8
21
9
34
10
55
11
89
12
144
13
233
14
377
15
610
16
987
17
1597
18
2584
19
4181
20
6765
21
10946
22
17711
23
28657
24
46368
25
75025
26
121393
27
196418
28
317811
29
514229
30
832040
31
1346269
32
2178309
33
3524578
34
5702887
35
9227465
36
14930352
37
24157817
38
39088169
39
63245986
40
102334155
41
165580141
42
267914296
43
433494437
44
701408733
45
1134903170
46
1836311903
47
2971215073
48
4807526976
49
7778742049"</assert-eq>
      </result>
   </test-case>

   <test-case name="xqhof4" covers="dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
         declare function local:hof($s, $f as function(*)) {
           $f($s[1], $s[2])
         };
         
         local:hof(('1', '2'), concat#2)
      </test>
      <result>
         <assert-eq>"12"</assert-eq>
      </result>
   </test-case>

   <test-case name="xqhof5" covers="partial-function-application">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>
         let $a := string-join(?, "")
         return $a(("foo", "bar", "baz"))
      </test>
      <result>
         <assert-eq>"foobarbaz"</assert-eq>
      </result>
   </test-case>

   <test-case name="xqhof6" covers="partial-function-application">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
         declare function local:curry($f as function(item()*, item()*) as item()*) as function(item()*) as function(item()*) as item()*
         {
           function($a) { $f($a, ?) }
         };
         
         local:curry(substring-after#2)("foobar")("foo")
      </test>
      <result>
         <assert-eq>"bar"</assert-eq>
      </result>
   </test-case>

   <test-case name="xqhof7" covers="dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>concat#3("one", "two")</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="xqhof8" covers="partial-function-application dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>concat#4("one", ?, "three")</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="xqhof9" covers="partial-function-application dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>concat#2("one", ?, "three")</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="xqhof10" covers="partial-function-application dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>
         for $f in (concat("one ", ?, " three"), substring-before("one two three", ?), matches(?, "t.*o"), xs:NCName(?))
         return $f("two")
      </test>
      <result>
        <assert-deep-eq>"one two three", "one ", true(), xs:NCName("two")</assert-deep-eq>
      </result>
   </test-case>

   <test-case name="xqhof11" covers="dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>()("two")</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="xqhof12" covers="partial-function-application">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XP30+ XQ30+"/>
      <test>(concat("one ", ?, " three"), substring-before("one two three", ?), matches(?, "t.*o"), xs:NCName(?))("two")</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>

   <test-case name="xqhof13" covers="dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
         let $f := function($a) { node-name(.), $a }
         return <a/>/$f(5)
      ]]>
      </test>
      <result>
         <error code="XPDY0002"/>
      </result>
   </test-case>

   <test-case name="xqhof14" covers="dynamic-function-call">
      <description></description>
      <created by="John Snelson" on="2011-07-28"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
         let $f := name#0
         return <a/>/$f()
      ]]>
      </test>
      <result>
         <error code="XPDY0002"/>
      </result>
   </test-case>

   <test-case name="xqhof15" covers="dynamic-function-call">
      <description>Test closure over context</description>
      <created by="John Snelson" on="2012-05-23"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
         let $f := <b/>/name#0
         return <a/>/$f()
      ]]>
      </test>
      <result>
         <assert-eq>"b"</assert-eq>
      </result>
   </test-case>

   <test-case name="xqhof16" covers="dynamic-function-call">
      <description>Test closure over context</description>
      <created by="John Snelson" on="2012-05-23"/>
      <modified by="O'Neil Delpratt" on="2012-10-01" change="Bug fix relating to issue #17281. Wrap results in ends-with functions" />
      <module uri="lib" file="HigherOrderFunctions/module-xqhof16.xq"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
         declare base-uri "main";
         import module namespace lib = "lib";
         
         lib:getfun()(),
         fn:static-base-uri#0(),
         fn:static-base-uri()
      </test>
      <result>
         <all-of>
            <assert>fn:ends-with($result[1], "lib")</assert>
            <assert>fn:ends-with($result[2], "main")</assert>
            <assert>fn:ends-with($result[3], "main")</assert>
         </all-of>
      </result>
   </test-case>

   <test-case name="xqhof17" covers="dynamic-function-call">
      <description>Test closure over context</description>
      <created by="John Snelson" on="2012-05-23"/>
      <module uri="lib" file="HigherOrderFunctions/module-xqhof16.xq"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
         import module namespace lib = "lib";
         
         <main/>/lib:getfun2()(),
         <main/>/name#0(),
         <main/>/name()
      ]]></test>
      <result>
         <assert-deep-eq>"lib", "main", "main"</assert-deep-eq>
      </result>
   </test-case>

   <test-case name="xqhof18" covers="dynamic-function-call">
      <description>Test closure over context</description>
      <created by="John Snelson" on="2012-05-23"/>
      <modified by="O'Neil Delpratt" on="2012-10-01" change="Bug fix relating to issue #17281. Wrap results in ends-with functions" />
      <module uri="lib" file="HigherOrderFunctions/module-xqhof16.xq"/>
      <dependency type="spec" value="XQ30+"/>
      <test>
         declare base-uri "main";
         import module namespace lib = "lib";
         
         lib:getfun3()(xs:QName("fn:static-base-uri"),0)(),
         function-lookup#2(xs:QName("fn:static-base-uri"),0)(),
         function-lookup(xs:QName("fn:static-base-uri"),0)()
      </test>
      <result>
         <all-of>
            <assert>fn:ends-with($result[1], "lib")</assert>
            <assert>fn:ends-with($result[2], "main")</assert>
            <assert>fn:ends-with($result[3], "main")</assert>
         </all-of>
      </result>
   </test-case>

   <test-case name="xqhof19" covers="dynamic-function-call">
      <description>Test closure over context</description>
      <created by="John Snelson" on="2012-05-23"/>
      <module uri="lib" file="HigherOrderFunctions/module-xqhof16.xq"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
         import module namespace lib = "lib";
         
         <main/>/lib:getfun3()(xs:QName("fn:name"),0)(),
         <main/>/function-lookup#2(xs:QName("fn:name"),0)(),
         <main/>/function-lookup(xs:QName("fn:name"),0)()
      ]]></test>
      <result>
         <assert-deep-eq>"lib", "main", "main"</assert-deep-eq>
      </result>
   </test-case>


</test-set>
