<?xml version="1.0" encoding="UTF-8"?>
<test-set name="misc-HigherOrderFunctions" xmlns="http://www.w3.org/2010/09/qt-fots-catalog">
  <description>Tests for features associated with higher order functions</description>
  <link document="http://www.w3.org/TR/xquery-30/" idref="doc-xquery30-EQName" type="spec"/>
  <link document="XQuery" idref="__HOF" section-number="H.0.0.0.0.0.0.0" type="spec"/>
  <dependency type="feature" value="higherOrderFunctions"/>
  <environment name="user-defined-types">
    <schema file="../docs/userdefined.xsd" uri="http://www.w3.org/XQueryTest/userDefinedTypes">
      <description>A schema user defined types and constructor tests</description>
      <created by="Anonymous" on="2006-04-03"/>
    </schema>
  </environment>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-001">
    <description> named function reference, user-defined function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
        declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
        let $f := local:f#1 return $f(2)</test>
    <result-string>xs:decimal(&quot;3&quot;)</result-string>
    <result>
      <assert-eq>3</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-002">
    <description> named function reference, user-defined function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f() as xs:integer { 42 }; 
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := local:f#0 return $f()
      </test>
    <result-string>xs:decimal(&quot;42&quot;)</result-string>
    <result>
      <assert-eq>42</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-003">
    <description> named function reference, imported user-defined function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <module file="HigherOrderFunctions/module-hof-003.xq" uri="http://example.com/hof-003"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
        import module namespace m=&quot;http://example.com/hof-003&quot;; 
        let $f := m:f#1 return $f(17)</test>
    <result-string>xs:decimal(&quot;18&quot;)</result-string>
    <result>
      <assert-eq>18</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-004">
    <description> named function reference, system function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>let $f := fn:round#1 return $f(1.2345)</test>
    <result-string>xs:decimal(&quot;1&quot;)</result-string>
    <result>
      <assert-eq>1</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-005">
    <description> named function reference, system function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>let $f := concat#8 return $f('a','b','c','d','e','f','g','h')</test>
    <result-string>xs:string(&quot;abcdefgh&quot;)</result-string>
    <result>
      <assert-string-value>abcdefgh</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-006">
    <description> named function reference, user-defined function, default function namespace  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare default function namespace &quot;http://example.com/hof-006&quot;; 
      declare function g($x as xs:integer) as xs:integer { $x + 1 }; 
      let $f := g#1 return $f(21)
      </test>
    <result-string>xs:decimal(&quot;22&quot;)</result-string>
    <result>
      <assert-eq>22</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-007">
    <description> named function reference, constructor function, default namespace  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare default function namespace &quot;http://www.w3.org/2001/XMLSchema&quot;; 
      let $f := date#1 return $f('2008-01-31')
      </test>
    <result-string>xs:string(&quot;2008-01-31&quot;)</result-string>
    <result>
      <assert-string-value>2008-01-31</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-008">
    <description> named function reference, constructor function, non default namespace  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>let $f := xs:date#1 return $f('2008-01-31')</test>
    <result-string>xs:string(&quot;2008-01-31&quot;)</result-string>
    <result>
      <assert-string-value>2008-01-31</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-009">
    <description> named function reference, constructor function, used-defined atomic type  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <environment ref="user-defined-types"/>
    <dependency type="spec" value="XQ30+"/>
    <dependency type="feature" value="schemaImport"/>
    <test>
        import schema namespace a = &quot;http://www.w3.org/XQueryTest/userDefinedTypes&quot;; 
        let $f := a:hatsize#1 
        return ($f(8) instance of a:hatsize)
      </test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-010">
    <description> SequenceType function()  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      let $f as function(*) := local:f#1 return $f(2)
      </test>
    <result-string>xs:decimal(&quot;3&quot;)</result-string>
    <result>
      <assert-eq>3</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-011">
    <description> SequenceType function(x) as z  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:f($x as xs:integer) as xs:integer { $x + 3 }; 
      let $f as function(xs:integer) as xs:integer := local:f#1 
      return $f(2)
      </test>
    <result-string>xs:decimal(&quot;5&quot;)</result-string>
    <result>
      <assert-eq>5</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-012">
    <description> SequenceType function(x,y) as z  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:f($x as xs:integer, $y as xs:long) as xs:integer { $x + $y }; 
      let $f as function(xs:integer, xs:long) as xs:integer := local:f#2 
      return $f(2, xs:long(5))
      </test>
    <result-string>xs:decimal(&quot;7&quot;)</result-string>
    <result>
      <assert-eq>7</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-013">
    <description> Selecting from a sequence of functions  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:f($x as xs:integer) as xs:integer { $x + 3 }; 
      declare function local:g($x as xs:integer) as xs:integer { $x + 4 }; 
      declare function local:h($x as xs:integer) as xs:integer { $x + 5 }; 
      let $f as (function(xs:integer) as xs:integer)* := (local:f#1, local:g#1, local:h#1) return $f[3](2)[1]
      </test>
    <result-string>xs:decimal(&quot;7&quot;)</result-string>
    <result>
      <assert-eq>7</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-014">
    <description> Function returning a function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:case($x as xs:boolean) as function(*) 
      	{ if ($x) then fn:upper-case#1 else fn:lower-case#1 }; 
      local:case(true())(&quot;Mike&quot;), local:case(false())(&quot;Mike&quot;)
      </test>
    <result-string>xs:string(&quot;MIKE mike&quot;)</result-string>
    <result>
      <assert-string-value>MIKE mike</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-015">
    <description> Function returning a function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:case($x as xs:boolean) as function(xs:string?) as xs:string 
      	{ if ($x) then fn:upper-case#1 else fn:lower-case#1 }; 
      local:case(true())(&quot;Mike&quot;), local:case(false())(&quot;Mike&quot;)</test>
    <result-string>xs:string(&quot;MIKE mike&quot;)</result-string>
    <result>
      <assert-string-value>MIKE mike</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-016">
    <description> Function expecting a function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:case($x as function(*), $y as xs:string) as xs:string { $x($y) }; 
      local:case(upper-case#1, &quot;Mike&quot;), local:case(lower-case#1, &quot;Mike&quot;)
      </test>
    <result-string>xs:string(&quot;MIKE mike&quot;)</result-string>
    <result>
      <assert-string-value>MIKE mike</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-017">
    <description> Function expecting a function, full signature  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:case($x as function(xs:string?) as xs:string, $y as xs:string) as xs:string { $x($y) }; 
      local:case(upper-case#1, &quot;Mike&quot;), local:case(lower-case#1, &quot;Mike&quot;)
      </test>
    <result-string>xs:string(&quot;MIKE mike&quot;)</result-string>
    <result>
      <assert-string-value>MIKE mike</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-018">
    <description> Function expecting a function, caller supplies local function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string 
      	{ $x($y) }; 
      declare function local:rot13($x as xs:string) as xs:string 
      	{ translate($x, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;nopqrstuvwxyzabcdefghijklm&quot;) }; 
      local:scramble(local:rot13#1, &quot;mike&quot;)
      </test>
    <result-string>xs:string(&quot;zvxr&quot;)</result-string>
    <result>
      <assert-string-value>zvxr</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-019">
    <description> Function expecting a function, caller supplies local function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) }; 
      declare function local:rot13($x as xs:string) as xs:string { translate($x, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;nopqrstuvwxyzabcdefghijklm&quot;) }; 
      local:scramble(local:rot13#1, &quot;mike&quot;)
      </test>
    <result-string>xs:string(&quot;zvxr&quot;)</result-string>
    <result>
      <assert-string-value>zvxr</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-020">
    <description> Function expecting a function, caller supplies inline function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) }; 
      local:scramble(function($x){translate($x, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;nopqrstuvwxyzabcdefghijklm&quot;)}, &quot;john&quot;)
      </test>
    <result-string>xs:string(&quot;wbua&quot;)</result-string>
    <result>
      <assert-string-value>wbua</assert-string-value>
    </result>
  </test-case>
  <test-case covers="function-item-coercion" name="hof-021">
    <description> Function expecting a function, caller supplies inline function. Needs function coercion  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) }; 
      local:scramble(function($x){translate($x, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;nopqrstuvwxyzabcdefghijklm&quot;)}, &quot;john&quot;)
      </test>
    <result-string>xs:string(&quot;wbua&quot;)</result-string>
    <result>
      <assert-string-value>wbua</assert-string-value>
    </result>
  </test-case>
  <test-case covers="fn-function-name fn-function-arity" name="hof-022">
    <description> Name and arity of a user-defined function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) }; 
      let $n := function-name(local:scramble#2) 
      return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity(local:scramble#2))
      </test>
    <result-string>xs:string(&quot;scramble http://www.w3.org/2005/xquery-local-functions 2&quot;)</result-string>
    <result>
      <assert-string-value>scramble http://www.w3.org/2005/xquery-local-functions 2</assert-string-value>
    </result>
  </test-case>
  <test-case covers="fn-function-name fn-function-arity" name="hof-023">
    <description> Name and arity of a system function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>
        let $f := fn:function-name#1, $n := function-name($f) 
        return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))</test>
    <result-string>xs:string(&quot;function-name http://www.w3.org/2005/xpath-functions 1&quot;)</result-string>
    <result>
      <assert-string-value>function-name http://www.w3.org/2005/xpath-functions 1</assert-string-value>
    </result>
  </test-case>
  <test-case covers="fn-function-name fn-function-arity" name="hof-024">
    <description> Name and arity of a constructor function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>
        let $f := xs:dateTime#1, $n := function-name($f) 
        return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))</test>
    <result-string>xs:string(&quot;dateTime http://www.w3.org/2001/XMLSchema 1&quot;)</result-string>
    <result>
      <assert-string-value>dateTime http://www.w3.org/2001/XMLSchema 1</assert-string-value>
    </result>
  </test-case>
  <test-case covers="fn-function-name fn-function-arity" name="hof-025">
    <description> Name and arity of a concat function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>let $f := concat#123456, $n := function-name($f) 
        return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))</test>
    <result-string>xs:string(&quot;concat http://www.w3.org/2005/xpath-functions 123456&quot;)</result-string>
    <result>
      <assert-string-value>concat http://www.w3.org/2005/xpath-functions 123456</assert-string-value>
    </result>
  </test-case>
  <test-case covers="fn-function-name fn-function-arity inline-function" name="hof-026">
    <description> Name and arity of an inline function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
        let $f := function($x as xs:string) as xs:string { upper-case($x) } 
        let $n := function-name($f) 
        return <a loc="{local-name-from-QName($n)}" uri="{namespace-uri-from-QName($n)}"
        			arity="{function-arity($f)}" eloc="{empty(local-name-from-QName($n))}" euri="{empty(namespace-uri-from-QName($n))}"/>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<a uri="" loc="" euri="true" eloc="true" arity="1"/>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case covers="partial-function-application dynamic-function-call" name="hof-027">
    <description> Curry a system function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>
        let $f := fn:contains(?, &quot;e&quot;) 
        return for $s in (&quot;Mike&quot;, &quot;John&quot;, &quot;Dave&quot;, &quot;Mary&quot;, &quot;Jane&quot;) return $f($s)</test>
    <result-string>xs:string(&quot;true false true false true&quot;)</result-string>
    <result>
      <assert-string-value>true false true false true</assert-string-value>
    </result>
  </test-case>
  <test-case covers="function-item-coercion dynamic-function-call" name="hof-028">
    <description> Return an inline function from a user-defined function. Needs function coercion  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:splitter() as (function(xs:string) as xs:string*) { function($x as xs:string) { tokenize($x, '\s') } }; 
      string-join(local:splitter()(&quot;A nice cup of tea&quot;), '|')
      </test>
    <result-string>xs:string(&quot;A|nice|cup|of|tea&quot;)</result-string>
    <result>
      <assert-string-value>A|nice|cup|of|tea</assert-string-value>
    </result>
  </test-case>
  <test-case covers="function-item-coercion dynamic-function-call" name="hof-029">
    <description> Return an inline function that uses internal variables. Needs function coercion  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:splitter() as (function(xs:string) as xs:string+)? 
      { function($x as xs:string) { for $i in tokenize($x, '\s') return upper-case($i)} }; 
      string-join(local:splitter()(&quot;A nice cup of tea&quot;), '|')
      </test>
    <result-string>xs:string(&quot;A|NICE|CUP|OF|TEA&quot;)</result-string>
    <result>
      <assert-string-value>A|NICE|CUP|OF|TEA</assert-string-value>
    </result>
  </test-case>
  <test-case covers="inline-function dynamic-function-call" name="hof-030">
    <description> Return an inline function that uses global variables  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare variable $sep as xs:string := &quot;\s&quot;; 
      declare function local:splitter() as (function(xs:string) as xs:string*)? 
      	{ function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} }; 
      string-join(local:splitter()(&quot;A nice cup of tea&quot;), '|')
      </test>
    <result-string>xs:string(&quot;A|NICE|CUP|OF|TEA&quot;)</result-string>
    <result>
      <assert-string-value>A|NICE|CUP|OF|TEA</assert-string-value>
    </result>
  </test-case>
  <test-case covers="inline-function dynamic-function-call" name="hof-031">
    <description> Return an inline function that uses local parameters  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:splitter($sep as xs:string) as (function(xs:string) as xs:string*) 
      	{ function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} }; 
      string-join(local:splitter(&quot;\s&quot;)(&quot;A nice cup of tea&quot;), '|')
      </test>
    <result-string>xs:string(&quot;A|NICE|CUP|OF|TEA&quot;)</result-string>
    <result>
      <assert-string-value>A|NICE|CUP|OF|TEA</assert-string-value>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="hof-032">
    <description> Parenthesized expression in a function call  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>(if (current-date() gt xs:date('2000-12-31')) then upper-case#1 else lower-case#1)(&quot;Mike&quot;)</test>
    <result-string>xs:string(&quot;MIKE&quot;)</result-string>
    <result>
      <assert-string-value>MIKE</assert-string-value>
    </result>
  </test-case>
  <test-case covers="fn-function-name dynamic-function-call" name="hof-033">
    <description> Context item is a function item  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>local-name-from-QName(function-name((upper-case#1, lower-case#1)[.(&quot;Mike&quot;) = &quot;MIKE&quot;]))</test>
    <result-string>xs:string(&quot;upper-case&quot;)</result-string>
    <result>
      <assert-string-value>upper-case</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-034">
    <description> ordered{} applied to a function item  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered{.}(&quot;Mike&quot;) = &quot;MIKE&quot;]))</test>
    <result-string>xs:string(&quot;upper-case&quot;)</result-string>
    <result>
      <assert-string-value>upper-case</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-035">
    <description> unordered{} applied to a function item  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered{.}(&quot;Mike&quot;) = &quot;MIKE&quot;]))</test>
    <result-string>xs:string(&quot;upper-case&quot;)</result-string>
    <result>
      <assert-string-value>upper-case</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-036">
    <description> Heterogeneous sequence of atomics and functions on rhs of &quot;/&quot;   </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[(<a b="3"/>/(string(@b), upper-case#1, 17))[. instance of xs:anyAtomicType]]]>
    </test>
    <result-string>xs:string(&quot;3 17&quot;)</result-string>
    <result>
      <assert-string-value>3 17</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-037">
    <description> instance-of tests on user-defined function, varying the argument types - all true  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
        declare function local:f($x as xs:long, $y as xs:NCName) as element(e) { 
            <e x="{$x}" y="{$y}"/> 
        }; 
        local:f#2 instance of function(*), 
        local:f#2 instance of function(xs:long, xs:NCName) as element(e), 
        local:f#2 instance of function(xs:anyAtomicType?, xs:anyAtomicType?) as element(e), 
        local:f#2 instance of function(item()*, item()*) as element(e)
      ]]>
    </test>
    <result-string>xs:string(&quot;true true false false&quot;)</result-string>
    <result>
      <assert-string-value>true true false false</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-038">
    <description> instance-of tests on user-defined function, varying the argument types - all false  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
        declare function local:f($x as xs:long?, $y as xs:NCName?) as element(e) { 
            <e x="{$x}" y="{$y}"/> 
        }; 
        local:f#2 instance of function(xs:int?, xs:NCName?) as element(e), 
        local:f#2 instance of function(xs:long?) as element(e), 
        local:f#2 instance of function(xs:long?, xs:NCName?, item()*) as element(e), 
        local:f#2 instance of function(xs:long, xs:anyAtomicType?) as element(e), 
        local:f#2 instance of function(item()+, item()+) as element(e)
      ]]>
    </test>
    <result-string>xs:string(&quot;true false false false false&quot;)</result-string>
    <result>
      <assert-string-value>true false false false false</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-039">
    <description> instance-of tests on user-defined function, varying the result types  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <modified by="O'Neil Delpratt" change="Related to bug issue #15999" on="2012-10-01"/>
    <modified by="Tim Mills" change="Reflect resolution of bug #15999" on="2013-02-26"/>
    <modified by="Michael Kay" change="There are now six results for the six sub-tests (was: 8 results for 6 tests)" on="2013-03-05"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
      	declare function local:f($x as xs:long, $y as xs:NCName) as element(e)? { <e x="{$x}" y="{$y}"/> }; 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType?)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?
      ]]>
    </test>
    <result-string>xs:string(&quot;true true true true true false&quot;)</result-string>
    <result>
      <assert-string-value>true true true true true false</assert-string-value>
    </result>
  </test-case>
  <test-case covers="function-item-coercion" name="hof-040">
    <description> Pass a sequence of functions that require coercion in different ways  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* { for $f in $fns return $f($s) }; 
      let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) 
      return string-join(local:apply($ops, 'Michael Kay'), '~')
      </test>
    <result-string>xs:string(&quot;MICHAEL KAY~michael kay~Michail Kay~Michael&quot;)</result-string>
    <result>
      <assert-string-value>MICHAEL KAY~michael kay~Michail Kay~Michael</assert-string-value>
    </result>
  </test-case>
  <test-case covers="partial-function-application function-item-coercion" name="hof-041">
    <description> Return a sequence of functions that require coercion in different ways  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:ops() as (function(xs:string) as xs:string)*
      	{ (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) }; 
      string-join(for $f in local:ops() return $f('Michael Kay'), '~')
      </test>
    <result-string>xs:string(&quot;MICHAEL KAY~michael kay~Michail Kay~Michael&quot;)</result-string>
    <result>
      <assert-string-value>MICHAEL KAY~michael kay~Michail Kay~Michael</assert-string-value>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="hof-042">
    <description> Implicit atomization works for various kinds of functions  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
        declare function local:lower-case($x as xs:string) as xs:string { concat("'", fn:lower-case($x), "'") }; 
        declare function local:ops() as (function(xs:string) as xs:string)* 
        	{ (upper-case#1, local:lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) }; 
        string-join(for $f in local:ops() return $f(<a name="Michael Kay"/>/@name), '~')
      ]]>
    </test>
    <result-string>xs:string(&quot;MICHAEL KAY~'michael kay'~Michail Kay~Michael&quot;)</result-string>
    <result>
      <assert-string-value>MICHAEL KAY~'michael kay'~Michail Kay~Michael</assert-string-value>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="hof-043">
    <description> untypedAtomic conversion works for various kinds of functions  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:round($x as xs:double) as xs:double 
      	{ fn:floor($x) }; 
      declare function local:ops() as (function(xs:double) as xs:double)* 
      	{ (abs#1, local:round#1, function($x){$x+1}, round-half-to-even(?, 2)) }; 
      string-join(for $f in local:ops() return string($f(xs:untypedAtomic('123.456'))), '~')
      </test>
    <result-string>xs:string(&quot;123.456~123~124.456~123.46&quot;)</result-string>
    <result>
      <assert-string-value>123.456~123~124.456~123.46</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-044">
    <description> numeric promotion works for various kinds of functions  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <modified by="Michael Kay" change="see bug #15402" on="2011-01-03"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:round($x as xs:double) as xs:double { fn:floor($x) }; 
      declare function local:ops() as (function(xs:double) as xs:double)* 
      	{ (abs#1, local:round#1, function($x as xs:double){$x+1}, round-half-to-even(?, 2)) }; 
      string-join(for $f in local:ops() return string(round-half-to-even($f(xs:decimal('123.456')), 4)), '~')
      </test>
    <result-string>xs:string(&quot;123.456~123~124.456~123.46&quot;)</result-string>
    <result>
      <assert-string-value>123.456~123~124.456~123.46</assert-string-value>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="hof-045">
    <description>partial-apply supplying a function parameter </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double { $algorithm($x) }; 
      declare variable $roundToCeiling := local:round(?, ceiling#1); $roundToCeiling(12.4)</test>
    <result-string>xs:decimal(&quot;13&quot;)</result-string>
    <result>
      <assert-eq>13</assert-eq>
    </result>
  </test-case>
  <test-case covers="inline-function" name="hof-046">
    <description>Return an inline function that uses inner and outer local variables</description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
        declare function local:splitter($x as xs:string) as (function() as xs:string*)* { 
            for $sep in ('\s', ',', '!') 
            return function() { for $i in tokenize($x, $sep) return upper-case($i) } 
        }; 
        <out>{ 
            for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.") 
            return <tokens>{ for $t in $f() 
                             return <t>{$t}</t> 
                   }</tokens> 
       }</out>
    ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<out><tokens><t>HOW</t><t>NICE!</t><t>THANK</t><t>YOU,</t><t>I</t><t>ENJOYED</t><t>THAT.</t></tokens><tokens><t>HOW NICE! THANK YOU</t><t> I ENJOYED THAT.</t></tokens><tokens><t>HOW NICE</t><t> THANK YOU, I ENJOYED THAT.</t></tokens></out>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case covers="inline-function dynamic-function-call" name="hof-047">
    <description> Nested inline functions referencing grandfather local variables </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
        declare function local:splitter($x as xs:string) as (function() as xs:string*)* { 
            for $sep in ('\s', ',', '!') return function() { 
                for $i in tokenize($x, $sep) return 
                    let $f := function(){ concat($sep, ':', upper-case($i)) } 
                    return $f() } 
        }; 
        <out>{ 
            for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.") 
            return <tokens>{ for $t in $f() 
                             return <t>{$t}</t> }</tokens> 
        }</out>
     ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<out><tokens><t>\s:HOW</t><t>\s:NICE!</t><t>\s:THANK</t><t>\s:YOU,</t><t>\s:I</t><t>\s:ENJOYED</t><t>\s:THAT.</t></tokens><tokens><t>,:HOW NICE! THANK YOU</t><t>,: I ENJOYED THAT.</t></tokens><tokens><t>!:HOW NICE</t><t>!: THANK YOU, I ENJOYED THAT.</t></tokens></out>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case covers="named-function-ref forwards-references" name="hof-048">
    <description> Forwards reference to a literal function item  </description>
    <created by="Michael Kay" on="2010-08-14"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
        declare function local:do() as xs:integer { (local:f#1)(5) }; 
        declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
        local:do()</test>
    <result-string>xs:decimal(&quot;6&quot;)</result-string>
    <result>
      <assert-eq>6</assert-eq>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-049">
    <description> true#0 and false# as literal function items  </description>
    <created by="Michael Kay" on="2011-01-12"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
        declare function local:tf($i as xs:integer) as function () as xs:boolean { 
            if ($i) then true#0 else false#0 
        }; 
        <out>{(local:tf(0)(), local:tf(1)())}</out>
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<out>false true</out>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case covers="named-function-ref partial-function-application" name="hof-050">
    <description> Partial application of a literal function item  </description>
    <created by="Michael Kay" on="2011-06-20"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[let $f := fn:substring-before#2(?, '-') return <out>{$f('the-end-of-the-world')}</out>]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<out>the</out>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case covers="inline-function partial-function-application" name="hof-051">
    <description> Partial application of an inline function item  </description>
    <created by="Michael Kay" on="2011-06-20"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
        let $f := function($a as xs:string, $b as xs:string) { 
            starts-with($a, $b) and ends-with($a, $b)}(?, 'a') 
        return <out>{$f('abracadabra')}</out>]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<out>true</out>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="hof-052">
    <description> Repeated partial application of a function  </description>
    <created by="Michael Kay" on="2011-06-20"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[let $f := fn:concat#3(?, '*', ?) let $g := $f('[', ?) return <out>{$g(']')}</out>]]>
    </test>
    <result-string/>
    <result>
      <assert-xml>
        <![CDATA[<out>[*]</out>]]>
      </assert-xml>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-053">
    <description> instance-of tests on user-defined function, varying the result types  </description>
    <created by="Tim Mills" on="2013-02-26"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
      	declare function local:f($x as xs:long, $y as xs:NCName) as element(e, xs:anyAtomicType) { <e x="{$x}" y="{$y}"/> }; 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(), 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()+, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element()*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType?)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType)*, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType)?, 
      	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?
      ]]>
    </test>
    <result-string>xs:string(&quot;true true true true true true true true true false&quot;)</result-string>
    <result>
      <assert-string-value>true true true true true true true true true false</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-901">
    <description> inline function literal, unknown user-defined function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := local:g#1 return $f(2)</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPST0017&quot;))</result-string>
    <result>
      <error code="XPST0017"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-902">
    <description> inline function literal, unknown user-defined function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := local:f#3 return $f(2)
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPST0017&quot;))</result-string>
    <result>
      <error code="XPST0017"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-903">
    <description> inline function literal, unknown function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := xs:date#2 return $f('2008-03-01')
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPST0017&quot;))</result-string>
    <result>
      <error code="XPST0017"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-904">
    <description> inline function literal, unknown function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	let $f := concat#1 return $f('2008-03-01')
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPST0017&quot;))</result-string>
    <result>
      <error code="XPST0017"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-905">
    <description> apply string() to a function item  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	string(local:f#1)
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;FOTY0014&quot;))</result-string>
    <result>
      <error code="FOTY0014"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-906">
    <description> apply data() to a function item  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	exists(data(local:f#1))
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;FOTY0013&quot;))</result-string>
    <result>
      <error code="FOTY0013"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-907">
    <description> apply deep-equal() to a function item  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	deep-equal((1,2,3,4,local:f#1), (1,2,3,4,local:f#1))
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;FOTY0015&quot;))</result-string>
    <result>
      <error code="FOTY0015"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-908">
    <description> atomize a function item implicitly  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	local:f#1 eq 3
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;FOTY0013&quot;))</result-string>
    <result>
      <error code="FOTY0013"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-909">
    <description> atomize a function item implicitly  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      	declare function local:f($x as xs:integer) as xs:integer { $x + 1 }; 
      	number(local:f#1)
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;FOTY0013&quot;))</result-string>
    <result>
      <error code="FOTY0013"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref dynamic-function-call" name="hof-910">
    <description> In SequenceType syntax, Result type required if argument type given  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
        declare function local:f($x as xs:integer) as xs:integer {
            $x + 1
        };
        let $f as function(xs:integer) := local:f#1
        return $f(3)
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPST0003&quot;))</result-string>
    <result>
      <error code="XPST0003"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="hof-911">
    <description> Heterogeneous sequence on rhs of &quot;/&quot; </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[<a b="3"/>/(@b, upper-case#1)]]>
    </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0018&quot;))</result-string>
    <result>
      <error code="XPTY0018"/>
    </result>
  </test-case>
  <test-case covers="inline-function partial-function-application" name="hof-912">
    <description> Pass a sequence of functions that cannot be coerced to the required type  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
        declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* 
        { for $f in $fns return $f($s) };
        let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, 
            substring-before(?, ' ', ?)) 
        return string-join(local:apply($ops, 'Michael Kay'), '~')</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="hof-913">
    <description> Pass a sequence of functions that cannot be coerced to the required type  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
        declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* 
        { for $f in $fns return $f($s) }; 
        let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, 
            string-length#1) 
        return string-join(local:apply($ops, 'Michael Kay'), '~')</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="hof-914">
    <description> Pass a sequence of functions that cannot be coerced to the required type  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
        declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* 
        { for $f in $fns return $f($s) }; 
        let $ops := (upper-case#1, lower-case#1, function($x as xs:double){string($x)}) 
        return string-join(local:apply($ops, 'Michael Kay'), '~')</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="hof-915">
    <description> partial-apply, argument number out of range  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>let $ops := substring-before('abc', ' ', (), ?) return $ops('Michael Kay')</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPST0017&quot;))</result-string>
    <result>
      <error code="XPST0017"/>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="hof-916">
    <description> partial-apply, argument number out of range  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>let $ops := substring-before(?, ?) return $ops('Michael Kay')</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="hof-917">
    <description> partial-apply, argument value invalid for target function  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>let $ops := substring-before(?, 2) return $ops('Michael Kay')</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="hof-918">
    <description> partial-apply supplying an incorrect function parameter  </description>
    <created by="Michael Kay" on="2009-03-01"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
        declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double 
        { $algorithm($x) }; 
        declare variable $roundToCeiling := local:round(?, upper-case#1); 
        $roundToCeiling(12.4)
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="hof-919">
    <description> Was hof-044: test that numeric promotion works for various kinds of functions. But there's
      an error - the function item function($x as xs:float){$x+1} doesn't satisfy the required type
      (function(xs:double) as xs:double) because it doesn't accept a double as an argument.
      </description>
    <created by="Michael Kay" on="2012-01-03"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      declare function local:round($x as xs:double) as xs:double { fn:floor($x) }; 
      declare function local:ops() as (function(xs:double) as xs:double)* 
      	{ (abs#1, local:round#1, function($x as xs:float){$x+1}, round-half-to-even(?, 2)) }; 
      string-join(for $f in local:ops() return string(round-half-to-even($f(xs:decimal('123.456')), 4)), '~')
      </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <!-- XDM 3.0 function item data type -->
  <test-case covers="named-function-ref" name="function-item-1">
    <description>A function item is a value that represents a function.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>concat#64 instance of function(*)</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="function-item-2">
    <description>Function items can be invoked, which is the act of calling the function that the function item represents.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>string-join#1((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;))</test>
    <result-string>xs:string(&quot;abcdefghij&quot;)</result-string>
    <result>
      <assert-string-value>abcdefghij</assert-string-value>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="function-item-3">
    <description>Function items have no identity, cannot be compared, and have no serialization.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>string-join#1 is string-join#1</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="function-item-4">
    <description>Function items have no identity, cannot be compared, and have no serialization.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>string-join#1 eq string-join#1</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;FOTY0013&quot;))</result-string>
    <result>
      <error code="FOTY0013"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="function-item-5">
    <description>Function items have no identity, cannot be compared, and have no serialization.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XQ30+"/>
    <test>element a { avg#1 }</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XQTY0105&quot;))</result-string>
    <result>
      <error code="XQTY0105"/>
    </result>
  </test-case>
  <test-case covers="named-function-ref" name="function-item-6">
    <description>Function items have no identity, cannot be compared, and have no serialization.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XQ30+"/>
    <test>attribute a { avg#1 }</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;FOTY0013&quot;))</result-string>
    <result>
      <error code="FOTY0013"/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="function-item-7">
    <description>A function item consists of the following information: The set of variable values for the variables referenced by the function.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>(let $a := 92, $b := true() return function($c) { $a, $b, $c })(&quot;lala&quot;)</test>
    <result-string/>
    <result>
      <assert-deep-eq>92, true(), &quot;lala&quot;</assert-deep-eq>
    </result>
  </test-case>
  <test-case covers="fn-function-name" name="function-item-8">
    <description>A function item consists of the following information: The name of the function as a xs:QName.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function-name(function-name#1)</test>
    <result-string>xs:QName(&quot;fn:function-name&quot;)</result-string>
    <result>
      <assert-eq>xs:QName(&quot;fn:function-name&quot;)</assert-eq>
    </result>
  </test-case>
  <test-case covers="inline-function fn-function-name" name="function-item-9">
    <description>A function item consists of the following information: The name of the function as a xs:QName. This is potentially absent.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function-name(let $a := 92, $b := true() return function($c) { $a, $b, $c })</test>
    <result-string/>
    <result>
      <assert-count>0</assert-count>
    </result>
  </test-case>
  <test-case covers="inline-function" name="function-item-10">
    <description>A function item consists of the following information: The signature of the function item.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>(let $a := 92, $b := true() return function($c) { $a, $b, $c }) instance of function(item()*) as item()*</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="function-item-11">
    <description>A function item consists of the following information: The function implementation.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>(let $a := 92, $b := true() return function($c) { $a, $b, $c })((xs:QName(&quot;foo&quot;), 5.0e3))</test>
    <result-string/>
    <result>
      <assert-deep-eq>92, true(), fn:QName(&quot;&quot;,&quot;foo&quot;), 5000</assert-deep-eq>
    </result>
  </test-case>
  <test-case covers="inline-function" name="function-item-12">
    <description>function(item()) as item() is a subtype of function(*)</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as item()) as item() { $a } instance of function(*)</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="function-item-13">
    <description>function(item()) as xs:integer is a subtype of function(item()) as item()</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as item()) as xs:integer { $a } instance of function(item()) as item()</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="function-item-14">
    <description>function(xs:string) as item() is a subtype of function(item()) as item()</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as item()) as item() { $a } instance of function(xs:string) as item()</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="function-item-15">
    <description>function(item()) as item() is not a subtype of function() as item()</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as item()) as item() { $a } instance of function() as item()</test>
    <result-string>xs:boolean(&quot;false&quot;)</result-string>
    <result>
      <assert-false/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="function-item-16">
    <description>function(item()) as xs:integer is no a subtype of function(item(), item()) as item()</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as item()) as xs:integer { $a } instance of function(item(), item()) as item()</test>
    <result-string>xs:boolean(&quot;false&quot;)</result-string>
    <result>
      <assert-false/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="function-item-17">
    <description>function(item()) as item() is not a subtype of function(xs:string) as item()</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as xs:string) as item() { $a } instance of function(item()) as item()</test>
    <result-string>xs:boolean(&quot;false&quot;)</result-string>
    <result>
      <assert-false/>
    </result>
  </test-case>
  <!-- XQuery 3.0 Inline functions (3.1.7 Inline Functions) -->
  <test-case covers="inline-function" name="inline-function-1">
    <description>An inline function expression creates a function</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function() { 5 } instance of function(*)</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-2">
    <description>that represents an anonymous function</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function-name(function() { 5 })</test>
    <result-string/>
    <result>
      <assert-count>0</assert-count>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-3">
    <description>An inline function specifies the names and SequenceTypes of the parameters to the function, the SequenceType of the result, and the body of the function.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function() as xs:integer { 5 }()</test>
    <result-string>xs:decimal(&quot;5&quot;)</result-string>
    <result>
      <assert-eq>5</assert-eq>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-4">
    <description>An inline function specifies the names and SequenceTypes of the parameters to the function, the SequenceType of the result, and the body of the function.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as xs:integer) as xs:integer { $a + 5 }(3)</test>
    <result-string>xs:decimal(&quot;8&quot;)</result-string>
    <result>
      <assert-eq>8</assert-eq>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-5">
    <description>An inline function specifies the names and SequenceTypes of the parameters to the function, the SequenceType of the result, and the body of the function.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as xs:integer, $b as xs:double) as xs:double { $a * $b + 5 }(3, 2)</test>
    <result-string>xs:decimal(&quot;11&quot;)</result-string>
    <result>
      <assert-eq>11</assert-eq>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-6">
    <description>If a function parameter is declared using a name but no type, its default type is item()*.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a, $b as xs:double) as xs:double { $a * $b + 5 } instance of function(item()*, xs:double) as xs:double</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-7">
    <description>If a function parameter is declared using a name but no type, its default type is item()*.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as node()+, $b) as xs:double { $a * $b + 5 } instance of function(node(), item()*) as xs:double</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-8">
    <description>If the result type is omitted from a function declaration, its default result type is item()*.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a as node()+) { $a + 5 } instance of function(node()) as item()*</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-9">
    <description>If the result type is omitted from a function declaration, its default result type is item()*.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function() { true() } instance of function() as item()*</test>
    <result-string>xs:boolean(&quot;true&quot;)</result-string>
    <result>
      <assert-true/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-10">
    <description>The parameters of a function declaration are considered to be variables whose scope is the function body.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a) { &quot;lala&quot;, $a }, $a</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPST0008&quot;))</result-string>
    <result>
      <error code="XPST0008"/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-11">
    <description>The parameters of a function declaration are considered to be variables whose scope is the function body.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>let $a := &quot;monkey&quot; return function($a) { &quot;lala&quot;, $a }(&quot;gibbon&quot;)</test>
    <result-string/>
    <result>
      <assert-deep-eq>&quot;lala&quot;, &quot;gibbon&quot;</assert-deep-eq>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-12">
    <description>The parameters of a function declaration are considered to be variables whose scope is the function body.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>$a, function($a) { &quot;lala&quot;, $a }</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPST0008&quot;))</result-string>
    <result>
      <error code="XPST0008"/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-11a">
    <description>The parameters of a function declaration are considered to be variables whose scope is the function body.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <modified by="O'Neil Delpratt" change="test case name already used, Bug #14453. Fixed by added 'a' to the test name" on="2011-10-13"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a) { let $a := &quot;monkey&quot; return (&quot;lala&quot;, $a) }(&quot;gibbon&quot;)</test>
    <result-string/>
    <result>
      <assert-deep-eq>&quot;lala&quot;, &quot;monkey&quot;</assert-deep-eq>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-12a">
    <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <modified by="O'Neil Delpratt" change="test case name already used, Bug #14453. Fixed by added 'a' to the test name" on="2011-10-13"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($a, $a) { &quot;lala&quot;, $a }(&quot;gibbon&quot;, &quot;monkey&quot;)</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XQST0039&quot;))</result-string>
    <result>
      <error code="XQST0039"/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-13">
    <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <modified by="Michael Kay" change="Invalid as an XPath 3.0 test (prefix undeclared). Replaced with -15" on="2013-04-05"/>
    <dependency type="spec" value="XQ30+"/>
    <test>function($local:foo, $local:bar, $local:foo) { &quot;lala&quot;, $local:foo, $local:bar }(&quot;gibbon&quot;, &quot;monkey&quot;, &quot;ape&quot;)</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XQST0039&quot;))</result-string>
    <result>
      <error code="XQST0039"/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-14">
    <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
    <created by="John Snelson" on="2011-07-28"/>
    <modified by="Michael Kay" change="Invalid as an XPath 3.0 test (prefix undeclared). Replaced with -16" on="2013-04-05"/>
    <dependency type="spec" value="XQ30+"/>
    <test>function($local:foo, $local:bar, $fn:foo) { &quot;lala&quot;, $local:foo, $local:bar }(&quot;gibbon&quot;, &quot;monkey&quot;, &quot;ape&quot;)</test>
    <result-string/>
    <result>
      <assert-deep-eq>&quot;lala&quot;, &quot;gibbon&quot;, &quot;monkey&quot;</assert-deep-eq>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-15">
    <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
    <created by="Michael Kay" on="2013-04-05"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($Q{http://local/}foo, $Q{http://local/}bar, $Q{http://local/}foo) { 
              &quot;lala&quot;, $Q{http://local/}foo, $Q{http://local/}bar }(&quot;gibbon&quot;, &quot;monkey&quot;, &quot;ape&quot;)</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XQST0039&quot;))</result-string>
    <result>
      <error code="XQST0039"/>
    </result>
  </test-case>
  <test-case covers="inline-function" name="inline-function-16">
    <description>It is a static error [err:XQST0039] for a function declaration to have more than one parameter with the same name.</description>
    <created by="Michael Kay" on="2013-04-05"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>function($Q{http://local/}foo, $Q{http://local/}bar, $fn:foo) { 
               &quot;lala&quot;, $Q{http://local/}foo, $Q{http://local/}bar }(&quot;gibbon&quot;, &quot;monkey&quot;, &quot;ape&quot;)</test>
    <result-string/>
    <result>
      <assert-deep-eq>&quot;lala&quot;, &quot;gibbon&quot;, &quot;monkey&quot;</assert-deep-eq>
    </result>
  </test-case>
  <!--The static context for the function body is inherited from the location of the inline function expression, with the exception of the static type of the context item which is initially undefined.-->
  <!-- XQuery 3.0 Literal function items -->
  <!-- XQuery 3.0 Function items -->
  <!-- XQilla HOF tests -->
  <test-case covers="dynamic-function-call" name="xqhof1">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
declare namespace map = &quot;http://snelson.org.uk/functions/map&quot;;

declare function map:key($pair as function() as item()+) as item()
{
  $pair()[1]
};

declare function map:value($pair as function() as item()+) as item()*
{
  subsequence($pair(), 2)
};

declare function map:contains($map as (function() as item()+)*, $key as item())
  as xs:boolean
{
  map:process($map, $key, function($a) { true() }, false(),
    function($a) { () })
};

declare function map:get($map as (function() as item()+)*, $key as item())
  as item()*
{
  map:process($map, $key, map:value#1, (), function($a) { () })
};

declare function map:process(
  $map as (function() as item()+)*,
  $key as item(),
  $found as function(function() as item()+) as item()*,
  $notfound as item()*,
  $unused as function((function() as item()+)*) as item()*
) as item()*
{
  if(empty($map)) then $notfound
  else

  let $length := count($map)
  let $middle := $length idiv 2 + 1
  let $pair := $map[$middle]
  let $pair_key := $pair()[1]
  return
    if($pair_key eq $key) then (
      $unused(subsequence($map, 1, $middle - 1)),
      $found($pair),
      $unused(subsequence($map, $middle + 1))
    )
    else if($pair_key gt $key) then (
      map:process(subsequence($map, 1, $middle - 1), $key,
        $found, $notfound, $unused),
      $unused(subsequence($map, $middle))
    )
    else (
      $unused(subsequence($map, 1, $middle)),
      map:process(subsequence($map, $middle + 1), $key,
        $found, $notfound, $unused)
    )
};

declare function map:pair($key as item(), $value as item()*)
  as function() as item()+
{
  function() { $key, $value }
};

declare function map:put(
  $map as (function() as item()+)*,
  $key as item(),
  $value as item()*
) as (function() as item()+)+
{
  let $pair := map:pair($key, $value)
  return
    map:process($map, $key, function($a) { $pair }, $pair,
      function($a) { $a })
};

string-join(let $map := map:put(map:put(map:put(map:put(map:put(map:put((),
  &quot;a&quot;, &quot;aardvark&quot;),
  &quot;z&quot;, &quot;zebra&quot;),
  &quot;e&quot;, (&quot;elephant&quot;, &quot;eagle&quot;)),
  &quot;o&quot;, &quot;osterich&quot;),
  &quot;t&quot;, &quot;terrapin&quot;),
  &quot;a&quot;, &quot;antelope&quot;)
return (
  map:get($map, &quot;o&quot;),

  for $m in $map
  return concat(&quot;key: &quot;, map:key($m), &quot;, value: (&quot;,
    string-join(map:value($m), &quot;, &quot;), &quot;)&quot;))
, &quot;&quot;)
</test>
    <result-string>xs:string(&quot;&quot;osterich
key: a, value: (antelope)
key: e, value: (elephant, eagle)
key: o, value: (osterich)
key: t, value: (terrapin)
key: z, value: (zebra)&quot;&quot;)</result-string>
    <result>
      <assert-eq>&quot;osterich
key: a, value: (antelope)
key: e, value: (elephant, eagle)
key: o, value: (osterich)
key: t, value: (terrapin)
key: z, value: (zebra)&quot;</assert-eq>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof2">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <module file="HigherOrderFunctions/functional.xq" uri="http://snelson.org.uk/functions/functional"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
         import module namespace func = &quot;http://snelson.org.uk/functions/functional&quot;;
         
         let $f := func:curry(concat#5)
         return $f(&quot;foo&quot;)(&quot; bar&quot;)(&quot; baz&quot;)(&quot; what's&quot;)(&quot; next?&quot;)
      </test>
    <result-string>xs:string(&quot;&quot;foo bar baz what's next?&quot;&quot;)</result-string>
    <result>
      <assert-eq>&quot;foo bar baz what's next?&quot;</assert-eq>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof3">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <modified by="John Snelson" change="Spec change to map-pairs arguments. See Action item A-538-06" on="2013-05-20"/>
    <module file="HigherOrderFunctions/functional.xq" uri="http://snelson.org.uk/functions/functional"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
import module namespace func = &quot;http://snelson.org.uk/functions/functional&quot;;

declare function local:fib2_aux($result as xs:integer, $next as xs:integer, $n) as xs:integer*
{
  if($n eq 0) then () else (
  $result, local:fib2_aux($next, $next + $result, $n - 1))
};

declare function local:fib2($n) as xs:integer*
{
  local:fib2_aux(0, 1, $n)
};

declare function local:map-pairs($f,$a,$b)
{
  for-each-pair($a,$b,$f)
};

string-join(
for $a in subsequence(

let $interleave := func:curry(local:map-pairs#3)(function($a, $b) { $a, $b })
let $enumerate := $interleave(0 to 49)
return
$enumerate(local:fib2(50))

, 1, 100)
return string($a)
, &quot;&quot;)
      </test>
    <result-string>xs:string(&quot;&quot;0
0
1
1
2
1
3
2
4
3
5
5
6
8
7
13
8
21
9
34
10
55
11
89
12
144
13
233
14
377
15
610
16
987
17
1597
18
2584
19
4181
20
6765
21
10946
22
17711
23
28657
24
46368
25
75025
26
121393
27
196418
28
317811
29
514229
30
832040
31
1346269
32
2178309
33
3524578
34
5702887
35
9227465
36
14930352
37
24157817
38
39088169
39
63245986
40
102334155
41
165580141
42
267914296
43
433494437
44
701408733
45
1134903170
46
1836311903
47
2971215073
48
4807526976
49
7778742049&quot;&quot;)</result-string>
    <result>
      <assert-eq>&quot;0
0
1
1
2
1
3
2
4
3
5
5
6
8
7
13
8
21
9
34
10
55
11
89
12
144
13
233
14
377
15
610
16
987
17
1597
18
2584
19
4181
20
6765
21
10946
22
17711
23
28657
24
46368
25
75025
26
121393
27
196418
28
317811
29
514229
30
832040
31
1346269
32
2178309
33
3524578
34
5702887
35
9227465
36
14930352
37
24157817
38
39088169
39
63245986
40
102334155
41
165580141
42
267914296
43
433494437
44
701408733
45
1134903170
46
1836311903
47
2971215073
48
4807526976
49
7778742049&quot;</assert-eq>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof4">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
         declare function local:hof($s, $f as function(*)) {
           $f($s[1], $s[2])
         };
         
         local:hof(('1', '2'), concat#2)
      </test>
    <result-string>xs:string(&quot;&quot;12&quot;&quot;)</result-string>
    <result>
      <assert-eq>&quot;12&quot;</assert-eq>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="xqhof5">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>
         let $a := string-join(?, &quot;&quot;)
         return $a((&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;))
      </test>
    <result-string>xs:string(&quot;&quot;foobarbaz&quot;&quot;)</result-string>
    <result>
      <assert-eq>&quot;foobarbaz&quot;</assert-eq>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="xqhof6">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
         declare function local:curry($f as function(item()*, item()*) as item()*) as function(item()*) as function(item()*) as item()*
         {
           function($a) { $f($a, ?) }
         };
         
         local:curry(substring-after#2)(&quot;foobar&quot;)(&quot;foo&quot;)
      </test>
    <result-string>xs:string(&quot;&quot;bar&quot;&quot;)</result-string>
    <result>
      <assert-eq>&quot;bar&quot;</assert-eq>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof7">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>concat#3(&quot;one&quot;, &quot;two&quot;)</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="partial-function-application dynamic-function-call" name="xqhof8">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>concat#4(&quot;one&quot;, ?, &quot;three&quot;)</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="partial-function-application dynamic-function-call" name="xqhof9">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>concat#2(&quot;one&quot;, ?, &quot;three&quot;)</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="partial-function-application dynamic-function-call" name="xqhof10">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>
         for $f in (concat(&quot;one &quot;, ?, &quot; three&quot;), substring-before(&quot;one two three&quot;, ?), matches(?, &quot;t.*o&quot;), xs:NCName(?))
         return $f(&quot;two&quot;)
      </test>
    <result-string/>
    <result>
      <assert-deep-eq>&quot;one two three&quot;, &quot;one &quot;, true(), xs:NCName(&quot;two&quot;)</assert-deep-eq>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof11">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>()(&quot;two&quot;)</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="partial-function-application" name="xqhof12">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <test>(concat(&quot;one &quot;, ?, &quot; three&quot;), substring-before(&quot;one two three&quot;, ?), matches(?, &quot;t.*o&quot;), xs:NCName(?))(&quot;two&quot;)</test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPTY0004&quot;))</result-string>
    <result>
      <error code="XPTY0004"/>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof13">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
         let $f := function($a) { node-name(.), $a }
         return <a/>/$f(5)
      ]]>
    </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPDY0002&quot;))</result-string>
    <result>
      <error code="XPDY0002"/>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof14">
    <description/>
    <created by="John Snelson" on="2011-07-28"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
         let $f := name#0
         return <a/>/$f()
      ]]>
    </test>
    <result-string>fn:error(fn:QName(&quot;http://www.w3.org/2005/xqt-errors&quot;, &quot;XPDY0002&quot;))</result-string>
    <result>
      <error code="XPDY0002"/>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof15">
    <description>Test closure over context</description>
    <created by="John Snelson" on="2012-05-23"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
         let $f := <b/>/name#0
         return <a/>/$f()
      ]]>
    </test>
    <result-string>xs:string(&quot;&quot;b&quot;&quot;)</result-string>
    <result>
      <assert-eq>&quot;b&quot;</assert-eq>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof16">
    <description>Test closure over context</description>
    <created by="John Snelson" on="2012-05-23"/>
    <modified by="O'Neil Delpratt" change="Bug fix relating to issue #17281. Wrap results in ends-with functions" on="2012-10-01"/>
    <module file="HigherOrderFunctions/module-xqhof16.xq" uri="lib"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
         declare base-uri &quot;main&quot;;
         import module namespace lib = &quot;lib&quot;;
         
         lib:getfun()(),
         fn:static-base-uri#0(),
         fn:static-base-uri()
      </test>
    <result-string/>
    <result>
      <all-of>
        <assert>fn:ends-with($result[1], &quot;lib&quot;)</assert>
        <assert>fn:ends-with($result[2], &quot;main&quot;)</assert>
        <assert>fn:ends-with($result[3], &quot;main&quot;)</assert>
      </all-of>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof17">
    <description>Test closure over context</description>
    <created by="John Snelson" on="2012-05-23"/>
    <module file="HigherOrderFunctions/module-xqhof16.xq" uri="lib"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
         import module namespace lib = "lib";
         
         <main/>/lib:getfun2()(),
         <main/>/name#0(),
         <main/>/name()
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-deep-eq>&quot;lib&quot;, &quot;main&quot;, &quot;main&quot;</assert-deep-eq>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof18">
    <description>Test closure over context</description>
    <created by="John Snelson" on="2012-05-23"/>
    <modified by="O'Neil Delpratt" change="Bug fix relating to issue #17281. Wrap results in ends-with functions" on="2012-10-01"/>
    <module file="HigherOrderFunctions/module-xqhof16.xq" uri="lib"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
         declare base-uri &quot;main&quot;;
         import module namespace lib = &quot;lib&quot;;
         
         lib:getfun3()(xs:QName(&quot;fn:static-base-uri&quot;),0)(),
         function-lookup#2(xs:QName(&quot;fn:static-base-uri&quot;),0)(),
         function-lookup(xs:QName(&quot;fn:static-base-uri&quot;),0)()
      </test>
    <result-string/>
    <result>
      <all-of>
        <assert>fn:ends-with($result[1], &quot;lib&quot;)</assert>
        <assert>fn:ends-with($result[2], &quot;main&quot;)</assert>
        <assert>fn:ends-with($result[3], &quot;main&quot;)</assert>
      </all-of>
    </result>
  </test-case>
  <test-case covers="dynamic-function-call" name="xqhof19">
    <description>Test closure over context</description>
    <created by="John Snelson" on="2012-05-23"/>
    <module file="HigherOrderFunctions/module-xqhof16.xq" uri="lib"/>
    <dependency type="spec" value="XQ30+"/>
    <test>
      <![CDATA[
         import module namespace lib = "lib";
         
         <main/>/lib:getfun3()(xs:QName("fn:name"),0)(),
         <main/>/function-lookup#2(xs:QName("fn:name"),0)(),
         <main/>/function-lookup(xs:QName("fn:name"),0)()
      ]]>
    </test>
    <result-string/>
    <result>
      <assert-deep-eq>&quot;lib&quot;, &quot;main&quot;, &quot;main&quot;</assert-deep-eq>
    </result>
  </test-case>
</test-set>